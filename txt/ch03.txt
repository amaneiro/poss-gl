Infraestrutura Técnica

Os proxectos de software libre apóianse en tecnoloxías que facilitan a captura selectiva e a integración da información. Canto máis habilidoso sexas usando estas tecnoloxías, e persuadindo a outros a empregalas, maior éxito terá o teu proxecto. Esta afirmación só empezará a ser certa segundo vaia medrando o proxecto.Unha boa xestión da información é o que evita que os proxectos de software libre sexan esmagados polo peso da Lei de Brooks<footnote><para>Do seu libro<citetitle>The Mythical Man Month</citetitle>, 1975. Ver <ulink url="http://en.wikipedia.org/wiki/The_Mythical_Man-Month"></ulink> e <ulink url="http://en.wikipedia.org/wiki/Brooks_Law"></ulink>.</para></footnote>, que establece que engadir man de obra a un proxecto que vai con atraso fará que se atrase aínda máis. Fred Brooks observou que a complexidade dun proxecto aumenta a razón do <emphasis>cadrado</emphasis> do número de participantes. Mentres só estiver implicado un número reducido de persoas, cada un pode facilmente comunicarse cos demais; mais cando están implicadas centos de persoas, non é xa.posible que cada persoa permaneza constantemente informada do que están a facer todos os demais. Se o segredo dunha boa xestión dun proxecto de software libre reside en conseguir que todo o mundo sinta que está a traballar cos demais na mesma habitación, a pregunta obvia é: que pasa cando todos os que están nunha habitación abarrotada tratan de falar ao mesmo tempo?

Este problema non é novo. En habitacións abarrotadas, reais, a solución consiste en adoptar o denominado<firstterm>procedemento parlamentario</firstterm>: un conxunto de normas formais sobre como manter discusións en tempo real no seo de grandes grupos, como estar seguros de que ningunha.manifestación relevante se perde entre moreas de comentarios tipo "eu tamén", como formar subcomités, cómo estar seguros sobre cando foi tomada unha decisión, etc. Unha parte importante do procedemento parlamentario consiste en determinar como interaxe o grupo co seu sistema de xestión da información. Algúns comentarios son feitos coa vontade de que fiquen rexistrados nos arquivos, outros non. O propio arquivo está suxeito a manipulación directa, e é entendido non coma unha transcrición literal do que ocorreu, se non como a transcrición do que o grupo pretende <emphasis>decidir</emphasis> que ocorreu. Os arquivos non son monolíticos, adoptan diferentes formas para diferentes usos. Comprenden tanto as actas de cada reunión como as coleccións completas de todas as actas de todas as reunións, resumos, axendas e as súas anotacións, informes de comités, informes de colaboradores non presentes nas reunións, listas de temas a tratar, etc.

Como Internet non é realmente unha habitación, non temos que preocuparnos de replicar as partes do procedemento parlamentario que teñen a ver con manter unhas persoas caladas mentres outros falan. Mais cando se trata de técnicas de xestión da información, os proxectos de software libre ben xestionados poden compararse a procedementos parlamentarios dopados con esteroides. Dado que nos proxectos de software libre practicamente toda a comunicación se fai por escrito, os sistemas elaborados evoluíron para faceren axeitadamente o seguimento e a etiquetaxe dos datos; cara á minimización das repeticións para evitaren diverxencias espúreas; para o correcto almacenamento e recuperación dos datos; cara a corrixir a información errónea ou obsoleta; e cara a asociación entre si de bits de datos desaparellados en canto se observan novas conexións. Quen participa activamente en proxectos de software libre adopta moitas destas técnicas, e frecuentemente é quen de executar complexas operacións manuais para garantir que a información está a ser xestionada axeitadamente. Mais o traballo completo depende en grande medida da axuda de software sofisticado. Na medida do posible son precisamente as ferramentas de comunicación as que deberían asumir as máis das tarefas de direccionamiento, etiquetaxe, e gravación, e deberían achegarlle a información aos seres humanos da maneira máis axeitada. É obvio que na vida real os seres humanos van ter que intervir en moitas etapas do proceso, e é importante que o software facilite esas intervencións. Mais en xeral, se os seres humanos toman a precaución de etiquetar e encamiñar a información correctamente ao inserila pola primeira vez no sistema, o software debería estar configurado para tirar o máximo partido dos metadatos.

As recomendacións recollidas neste capítulo son principalmente prácticas, baseadas en experiencias con patróns de software específico e de uso. Mais a cuestión non é aprendervos unha colección particular de técnicas. É tamén a de demostrar, a través do uso de moitos pequenos exemplos, a actitude xeral que mellor se vai adecuar á correcta xestión da información nos vosos proxectos. Esta actitude envolve un conxunto de habilidades técnicas e habilidades persoais. As habilidades técnicas son esenciais dado que o software de xestión da información sempre ten que ser correctamente configurado, ademais de precisar de unha certa cantidade de mantemento permanente e de modificación en canto xurdir unha nova necesidade (como exemplo, botádelle unha ollada á discusión sobre como manexar o crecemento do proxecto en <xref linkend="filtraxe de erros"/><phrase output="printed"> máis adiante neste mesmo capítulo</phrase>). As habilidades persoais son necesarias xa que a comunidade humana tamén require de mantemento: non sempre é inmediatamente obvio o modo de empregar estas ferramentas para obter o mellor rendemento, e nalgúns casos os proxectos adoptan convencións conflitivas (como exemplo, podes ver a discusión sobre a configuración dos cabezallos <systemitem>Reply-to</systemitem> das mensaxes saíntes nas listas de correo ). Todos os que estiveren implicados no proxecto van precisar que, nalgún momento ou noutro e da maneira correcta, se lles force a facer a súa parte do traballo para manter ben organizada a información relativa ao mesmo. Canto máis implicado estiver o colaborador, máis complexas e especializadas serán as técnicas que se espera que aprenda.

Non existen solucións á medida para a xestión da información. Hai demasiadas variables. Podedes ter absolutamente todo configurado da maneira que queredes telo, e coa maioría da comunidade participando xa, mais entón o crecemento do proxecto fará que non sexa posible incrementar una desas prácticas. Ou o crecemento do proxecto pode terse estabilizado, e as comunidades de desenvolvedores e de usuarios manter unha confortable relación coa infraestrutura técnica, mais entón alguén se presentará cunha solución de xestión da información completamente nova, e os recentemente incorporados ao proxecto logo van comezar a preguntar por que non está a ser empregada&mdash; por exemplo, isto está a ocorrer actualmente cunha chea de proxectos de software libre anteriores á invención das wikis (véxase <ulink url="http://en.wikipedia.org/wiki/Wiki"></ulink>). Moitas decisións dependerán de matices, xa que van ser resoltas mediante compromisos entre os intereses de quen produce a información e os de quen a consume, ou do tempo requirido para configurar o software de xestión da información fronte aos beneficios que este poida achegar ao proxecto.

Loitade contra a tentación de hiper-automatizar, e dicir, de automatizar procesos que en realidade requiren da atención humana. A infraestrutura técnica é importante, mais o que fai que un proxecto de software libre funcione é o coidado&mdash;e a manifestación intelixente dese coidado&mdash; por parte dos individuos involucrados. A infraestrutura técnica ten a ver principalmente con fornecerlles aos humanos formas convenientes de facelo.

Que é o que un proxecto precisa

Os máis dos proxectos de software de código aberto ofrecen cando menos un conxunto mínimo e estándar de ferramentas para a xestión da información:

Sitio Web

É ante todo un conduto centralizado e unidireccional de transmisión de información desde o proxecto cara ao público. O sitio web pode tamén funcionar como interface administrativa para outras ferramentas do proxecto.

Listas de correo

Xeralmente constitúen os foros de comunicación máis activos do proxecto, ademais do "medio de arquivamento"

Control de versións

Permite aos desenvolvedores xestionaren convenientemente as mudanzas no código, incluíndo a reversión e o traslado de mudanzas ("change porting"). Permite tamén que todo o mundo saiba o que se está a facer co código.

Seguimento de erros ("Bug Tracking")

Permite aos desenvolvedores manteren o control sobre aquilo no que están a traballar, coordinárense cos demais e planificaren as publicacións de novas versións. Permite que todos os colaboradores poidan facer consultas sobre o estado en que se atopa a resolución de erros e gravar información (p.e.: procedementos de reprodución) sobre erros concretos. Pode ser usado non só para facer seguimento dos erros, senón tamén de tarefas, versións, novas funcionalidades, etc

Chat en tempo real (IRC)

É o lugar onde se celebran discusións rápidas e pouco transcendentes e se fan intercambios de preguntas/respostas. Non sempre se arquivan completamente.

Cada ferramenta das descritas aborda unha necesidade concreta, mais as súas funcións están inter-relacionadas, e deben estar configuradas de xeito que poidan traballar conxuntamente. Máis adiante examinaremos como facer iso e, máis importante, como conseguir que a xente as empregue. O sitio web non se trata ata o final, dado que actúa máis como aglomerante dos demais compoñentes que como unha ferramenta en si mesma.

Podedes evitar moitas das dores de cabeza derivadas da selección e configuración destas ferramentas empregando un sitio web do tipo<firstterm>canned hosting (aloxamento enlatado)</firstterm>: un servidor que ofrece áreas web preempacotadas e regularizadas que conteñen todas as ferramentas necesarias para manexar un proxecto de software libre. Podedes consultar o apartado <xref linkend="canned-hosting (aloxamento enlatado)"/><phrase output="printed"> máis adiante neste capítulo</phrase>, no que se discute sobre as vantaxes e desvantaxes deste tipo de sitios web.

Listas de Correo

As listas de correo son o pan e o sal das comunicacións nun proxecto. Se un usuario está exposto a un foro para alén das páxinas web, o máis probable é que se trate dunha das listas de correo do proxecto. Mais antes de chegar a usar as listas en si mesmas, primeiro terán que experimentar o uso das súas interfaces&mdash; é dicir, o mecanismo polo cal se subscriben ("suscribe to") á lista en cuestión. Isto nos leva á Regra nº1 das listas de correo:

Non tratedes de xerir as listas de correo manualmente&mdash;empregade software de xestión de listas

Deixar esta regra de lado pode resultar tentador. Configurar software para a xestión das listas pode parecer excesivo. Xestionar listas pequenas, con pouco tráfego de mensaxes a man pode resultar sedutoramente sinxelo: simplemente creas un enderezo de subscrición encamiñado a ti, e cando alguén manda unha mensaxe a ela, ti engades (ou borras) o seu enderezo de email dun arquivo de texto que contén todos os enderezos da lista. Podería ser máis sinxelo?

O truco está en que unha boa xestión da lista de correo&mdash;que é o que a xente espera&mdash;non é sinxela en absoluto. No se trata tan só de subscribir ou dar de baixa os usuarios cando o pediren. Ten tamén a ver con moderala, evitar o spam, ofertar a lista en formato de resumo de mensaxes ou nun formato que mostre todas as mensaxes, fornecer información estándar sobre a lista e o proxecto mediante mensaxes de resposta automática, e moitas outras cousas. Un ser humano que faga seguimento da lista de subscricións e baixas estará a fornecer tan só unha mínima parte das funcionalidades requiridas e, mesmo entón, non en forma tan segura e áxil como o faría o software.

O software de xestión de listas actual ofrece cando menos as seguintes utilidades:

Subscrición tanto por email como a través dunha páxina web

Cando un usuario se subscribe a unha lista debería recibir <emphasis>inmediatamente</emphasis> unha mensaxe automática de benvida, dicíndolle a que se subscribiu, como interaxir en adiante co software de xestión da lista e (moi importante) como darse de baixa. Esta resposta automática pode ser personalizada para que conteña información especifica do proxecto, desde logo, tal como o enderezo da súa páxina web,a localización das FAQ (Frequently Asked Questions = Preguntas Respondidas Frecuentemente), etc

Subscrición en modo "digest" (só resumos das mensaxes) ou en modo de mensaxes completas

En modo digest, o subscritor recibe só.unha mensaxe por día coa totalidade da actividade da lista nese día. Para xente que está a seguir unha lista de xeito desligado, sen participar realmente na súa actividade, o modo digest acostuma ser o máis axeitado, xa que lle permite explorar a totalidade das materias tratadas dunha vez e evitar a distracción que supón que as mensaxes estean entrando de maneira aleatoria.

Utilidades de moderación

"Moderar" consiste en controlar que as mensaxes entrantes:a)&nbsp;non son&nópico da bsp;spam, e b)&nbsp;se corresponden có&nbsp;tópico da lista, antes da súa distribución aos restantes usuarios da mesma. O feito de moderar as listas é unha tarefa tipicamente humana, mais o software pode contribuír enormemente a facela máis sinxela. Falaremos máis sobre a moderación máis adiante.

Interface administrativa

Entre outras cousas, permite ao administrador dar de baixa enderezos obsoletos de maneira sinxela. Isto pode ser urxente se o enderezo dun usuario comeza a emitir mensaxes automáticas do tipo "Non estou xa neste enderezo" en resposta a cada mensaxe enviada á lista. Algúns softwares de listas de correos poden mesmo detectar estas situacións por si mesmos e dar de baixa automaticamente á persoa en cuestión.

Manipulación de cabezallos

Moita xente ten activadas no seu software de correo electrónico regras de filtraxe e de resposta realmente sofisticadas. O software de xestión de listas de correo pode engadir e manipular os cabezallos estándar para que esta xente se beneficie delas (algúns detalles máis adiante).

<term>Arquivamento</term>

Todas as mensaxes enviadas ás listas xestionadas son almacenadas e postas á disposición dos interesados na web; alternativamente, algúns softwares de listas de correo ofrecen interfaces especiais para enlazar ferramentas externas de arquivamento tales como MHonArc (<ulink url="http://www.mhonarc.org/"></ulink>). Como se comenta en <xref linkend="usando os arquivos"/><phrase output="printed"> en <xref linkend="comunicacións"/></phrase> , o arquivamento é unha tarefa crucial.

A intención de todos estes comentarios é salientar que a xestión das listas de correo é un problema complexo sobre o que se ten pensado moito, e que foi en grande medida solucionado. Certamente, vós non precisades tornarvos en expertos na materia. Mais deberiades saber que sempre hai máis sobre o que aprender, e que a xestión das listas vai ocupar a vosa atención de cando en vez ao longo da vida dun proxecto de software libre. Máis adiante examinaremos unhas poucas das cuestións máis frecuentes relativas á configuración das listas de correo.

Prevención do spam

Entre o momento en que esta frase foi escrita e aquel en que foi publicada, seguramente o problema do spam ten duplicado a súa severidade&mdash;ou cando menos se percibirá dese xeito. Houbo un tempo, non hai tanto, cando un podía pór en marcha unha lista de correo sen ter que tomar ningunha medida anti-spam. A mensaxe perniciosa ocasional podía certamente aparecer, mais de xeito tan pouco frecuente que se consideraba un inconveniente de baixo nivel. Ese tempo foise para sempre. Hoxe en día, unha lista de correo que non adopte ningunha precaución anti-spam verase rapidamente asolagada por correos lixo, ata o punto de se tornar inutilizable. A prevención anti-spam é polo tanto obrigatoria.

A prevención anti-spam pode ser dividida en dúas categorías: a que prevén que entren mensaxes spam na túa lista, e aquela que trata de evitar que a lista se converta nunha fonte de enderezos de correo electrónico para os spammers que as colleitan. A primeira é a máis importante, así que a analizaremos en primeiro lugar.

Filtraxe das mensaxes

Hai tres técnicas básicas para evitar a entrada de mensaxes lixo, e os máis dos software de listas fornecen as tres. Traballan mellor cando se usan en tándem:

Soamente permitir automaticamente aquelas mensaxes enviadas á lista por subscritores.

Esta é unha medida efectiva cando está activa, e implica moi pouco traballo administrativo, xa que normalmente obriga a mudar tan só unha opción na configuración do software de xestión da lista. Mais tede en conta que as mensaxes que non son automaticamente aprobadas non deben ser simplemente descartadas. Pola contra, deben pasar a ser moderadas por dúas razóns. A primeira é que ides querer que os non subscritores poidan contribuír. Unha persoa que quere facer un comentario ou unha suxestión non debería ter que subscribirse tan só para enviar unha única mensaxe. En segundo lugar, mesmo os subscritores poden, en ocasións, enviar mensaxes desde enderezos distintos a aqueles cos que se cadastraron na lista. Os enderezos de correo electrónico no son un método fiable de identificación das persoas, e non deberían ser tratados como tales.

Filtraxe de mensaxes a través de software de control de spam.

Se o software da lista de correo o permitir (os máis deles o fan), podedes facer que as mensaxes sexan controladas por unha aplicación de filtraxe de spam. A filtraxe automática de spam non é perfecta, e nunca o vai ser, xa que hai unha carreira inacabable entre os spammers e os escritores de filtros. Porén, pode reducir sensiblemente a cantidade de spam que atravesa a ringleira de moderación, e dado que canto máis longa é a ringleira máis tempo de dedicación require dos humanos, calquera cantidade de filtraxe automática resulta beneficiosa.

Non temos espazo dabondo neste libro para transmitirvos instrucións detalladas sobre como configurar os filtros anti-spam. Teredes que consultar as instrucións do software da vosa lista (ver <xref linkend="software de listas de correo"/><phrase output="printed"> máis adiante neste capítulo</phrase>). O software de listas de correo inclúe frecuentemente algunha utilidade preconfigurada de prevención anti-spam, mais pode que vós queirades engadir algúns filtros de terceiros. Persoalmente teño boas experiencias con estes dous: SpamAssassin (<ulink url="http://spamassassin.apache.org/"></ulink>) e SpamProbe (<ulink url="http://spamprobe.sourceforge.net/"></ulink>). Isto non supón ningunha valoración de outros filtros anti-spam libres, algúns dos cales son aparentemente bastante bos. É só que eu usei os dous mencionados e quedei moi satisfeito con eles.

Moderación.

Para aquelas mensaxes que non foren automaticamente autorizadas por procederen dun subscritor da lista, e que pasaren a través do software de filtraxe de spam, se for o caso, o último paso é o da <firstterm>moderación</firstterm>: a mensaxe é enviada a un enderezo especial, no que un individuo a examina e decide se é aprobada ou rexeitada.

A aprobación dunha mensaxe pode facerse de dúas maneiras: pódese aceptar a mensaxe só por esta vez, ou podes dicirlle á lista que acepte esta e calquera outra mensaxe que no futuro proceda do mesmo remitente. As máis das veces é isto último o que se fai, xa que así se reduce a carga de traballo da moderación. Os detalles sobre como se fai varían de sistema a sistema, mais xeralmente consiste en responder a un determinado enderezo de correo coa mensaxe "aceptar" (o que quere dicir que se acepta tan só esta mensaxe) ou "permitir" (aprobando esta e outras mensaxes futuras).

O rexeitamento faise xeralmente ignorando a mensaxe de moderación. Se o software da lista non dá recibido a confirmación de que algo é unha mensaxe válida, non a pasará á lista, así que o efecto desexado se produce se simplemente non se dá curso á mensaxe de moderación. Ás veces tamén tés a opción de responderes cos comandos "rexeitar" ou "denegar", para que ningunha mensaxe do mesmo remitente sexa aceptada no futuro, sen necesidade de sometelas a moderación. Xeralmente non ten moito sentido facer isto, xa que a moderación tenta controlar o spam, e os spammers moi raramente empregan dúas veces o mesmo enderezo.

Tede coidado de empregardes a moderación <emphasis>tan só</emphasis> para filtrardes o spam e as mensaxes claramente fóra de tópico, como cando alguén manda accidentalmente un correo á lista equivocada. O sistema de moderación adoita permitir a resposta directa ao remitente, mais non se debe usar este método para dar resposta a preguntas que en realidade entran no ámbito de actividade da propia lista, aínda que teñades absolutamente clara a resposta. Facer iso privaría á comunidade do coñecemento exacto acerca de que clase de preguntas fai a xente, e impediríalles responder por eles mesmos ou ver as respostas que outros poidan enviar. A moderación das  listas de correo ten a ver exclusivamente con mantelas libres de correo lixo e mensaxes fóra de tópico, nada máis.

Ocultación de enderezos nos arquivos

Para evitares que as túas listas de correo se convertan nunha fonte de subministro de enderezos para os spammers, unha técnica habitual é a de que os arquivos oculten os enderezos da xente, por exemplo substituíndo

<blockquote> <para><literal>jrandom@somedomain.com</literal></para> </blockquote> <para>por</para> <blockquote> <para><literal>jrandom_AT_somedomain.com</literal></para> </blockquote> <para>ou</para> <blockquote> <para><literal>jrandomNOSPAM@somedomain.com</literal></para> </blockquote>

ou algunha maneira igualmente obvia (para os humanos) de codificalas. Dado que os colleitadores de enderezos para spam funcionan frecuentemente uliscando nas páxinas web&mdash;incluíndo os arquivos web da túa lista de correo&mdash;e buscando secuencias que conteñan "@", codificar os enderezos é a maneira de tornalos inútiles ou invisibles para os spammers. Por suposto que isto non evita que o spam sexa enviado directamente á propia lista, mais si que minimiza a cantidade de lixo que chega aos enderezos persoais dos membros da lista.

A ocultación de enderezos pode ser discutida. Gústalle moito a algunha xente , que se sorprenderá se os teus arquivos non o fan de maneira automática. Outra xente, pola contra, pensará que é unha incomodidade (xa ques as persoas terán tamén que traducir os enderezos antes de poder usalos). e hai xente que afirma que é unha práctica inútil, xa que un colleitador podería, en teoría, compensar calquera padrón de codificación. En calquera caso, hai evidencia empírica dabondo de que a ocultación de enderezos <emphasis>é</emphasis> efectiva, consulta <ulink url="http://www.cdt.org/speech/spam/030319spamreport.shtml"></ulink>.

Idealmente, o software de xestión da lista debería deixar a escolla en mans de cada subscritor, ben mediante un cabezallo especial tipo "Si/Non" ou cunha opción de configuración nas preferencias da conta da lista de ese subscritor en particular. Porén, non coñezo ningún software que ofreza esa opción para cada subscritor ou para cada mensaxe, así que polo de agora será o xestor da lista quen teña que tomar a decisión por todos (dando por sentado que o arquivo ofrece esa utilidade, o que non sempre é así) Eu inclínome lixeiramente cara a que a ocultación de enderezos estea activada. Algunhas persoas poñen moito coidado en non publicar os seus enderezos en páxinas web ou en calquera outro sitio onde un colleitador de spam poida localizalos, e sentiríanse moi incómodos se esa precaución fose tirada ao lixo por un arquivo de listas de correo; mentres tanto, o inconveniente que supón a ocultación de enderezos para as persoas é moi pouco importante, xa que a transformación de un enderezo oculto nun utilizable é trivial no caso de que precisares acceder á persoa en cuestión. Pero non esquezas que, ao final, non deixa de ser unha carreira armamentística: para cando leas isto, os colleitadores poden perfectamente ter evolucionado ata o punto de seren quen de recoñecer as formas máis habituais de ocultación, e teremos que empezar a pensar noutra solución.

Identificación e xestión de cabezallos

Frecuentemente, os subscritores das listas quererán arquivar as mensaxes nunha pasta específica para o proxecto, distinta das de outras mensaxes de correo. O seu software de lectura de correo pode facer isto automaticamente sen máis que examinar os <firstterm>cabezallos</firstterm> das mensaxes. Os cabezallos son os campos situados no inicio das mensaxes que indican quen é o remitente, o destinatario, cal é o asunto, a data e outra información variada acerca da mensaxe. Algúns cabezallos son ben coñecidos e certamente imprescindibles:

De: ...
Para: ...
Asunto: ...
Data: ...

Outras son opcionais, aínda que bastante habituais. Por exemplo, os emails non teñen por que levar o cabezallo

Responder a: remitente@enderezo de correo, 

mais as máis delas o levan, xa que lle ofrece ao destinatario un camiño seguro para acceder ao autor da mensaxe (o que é especialmente útil cando o autor tivo que enviar a mensaxe desde un enderezo distinto a aquel ao que desexa que se lle remitan as respostas).

Algún software de lectura de correo ofrece unha interface de uso sinxelo para filtrar mensaxes baseándose en padróns do cabezallo "asunto". Isto fai que a xente pida que a lista engada un prefixo automático a todos os asuntos, de xeito que se poida configurar o programa para que recoñeza ese prefixo e arquive automaticamente na pasta correcta as mensaxes que o levan. A idea é que o autor da mensaxe escribiría:

Asunto: preparando a liberación 2.5.

mais a mensaxe se vería na lista deste xeito:

Asunto: [discusions@listas.exemplo.org] preparando a liberación 2.5.

Aínda que a maioría dos programas de xestión de listas ofrecen esta opción, persoalmente recomendo non activala. O problema que resolve pode ser solucionado de maneira máis sinxela por métodos menos intrusivos, e o custo de reducir o espazo do cabezallo "asunto" é considerablemente superior. Os usuarios experimentados de listas de correo acostuman a ver os asuntos da lista de mensaxes entrantes do día para decidiren cal ler ou a cal responder. Se o nome da lista antecede o asunto, o contido deste pode ser desprazado cara ao lado dereito da pantalla, fóra do campo de visión. Isto oculta información que a xente necesita para decidiren que mensaxes abrir, reducindo así a utilidade xeral da lista para todo o mundo.

En troca de mudar excesivamente o cabezallo "asunto", aprende aos teus usuarios a tiraren partido de outros cabezallos estándar, comezando polo cabezallo "para", que debería conter o nome da lista:

Para: &lt;discusión@listas.exemplo.org&gt;

Calquera lector de correo que poida filtrar o "asunto" debería tamén poder filtrar o "para" coa mesma facilidade.

Hai uns poucos cabezallos máis de listas de correo que son opcionais mais estándar. Filtralos é mesmo máis preciso que facelo sobre os "para" ou "CC"; dado que estes cabezallos son engadidos ás mensaxes polo propio software de xestión de listas, algúns usuarios poden contar coa súa presenza:

axuda-lista: &lt;mailto:discuss-help@lists.example.org&gt;
baixa-lista: &lt;mailto:discuss-unsubscribe@lists.example.org&gt;
envio-a-lista: &lt;mailto:discuss@lists.example.org&gt;
Distribuído-a:: mailing list discuss@lists.example.org
Lista: contactar discuss-help@lists.example.org; run by ezmlm

Os máis deles son obvios. Consulta <ulink url="http://www.nisto.com/listspec/list-manager-intro.html"></ulink> para máis explicacións, ou se precisares especificacións realmente detalladas e formais, podes ver <ulink url="http://www.faqs.org/rfcs/rfc2369.html"></ulink>.

Ten en conta que estes cabezallos implican que, se tiveres unha  lista denominada "lista", tamén vas dispor de enderezos administrativos "axuda-lista" e "baixa-lista". Ademais, é habitual ter "subscrición-lista" para cadastrarse, e "propietario-lista" para contactar cos seus administradores. Xeralmente se envía automaticamente a explicación sobre a utilidade e todos estes enderezos aos novos subscritores como parte dunha mensaxe de benvida. Probablemente ti mesmo teñas copia desta mensaxes de benvida. Se non for así, pídelle a alguén que cha pase, para que poidas coñecer o que é que os teus usuarios reciben cando se dan de alta na lista. Ten a copia a man de xeito que poidas responder preguntas sobre o funcionamento da lista ou, mesmo mellor, publícaa nalgunha páxina web. Deste xeito, cando alguén perda a súa copia e che mande unha mensaxe preguntando "Como podo darme de baixa nesta lista?, ti só terás que enviarlle a correspondente URL.

Algúns programas de listas de correo ofrecen unha opción para engadir ao pé das mensaxes as instrucións para darse de baixa. Se for así, actívaa. Só produce un par de liñas de máis por mensaxe, nunha localización onde non estorban, e pode aforrarche unha boa cantidade de tempo diminuíndo a cantidade de xente que che envía consultas &mdash;ou peor, que manda unha mensaxe á lista!&mdash;preguntando como darse de baixa.

O Gran debate sobre "responder-a" (Reply-To)

Antes, en <xref linkend="evita discusións privadas"/>, salientei a importancia de manter discusións seguras nos foros públicos, e falei sobre como é as veces necesario adoptar medidas activas para evitares a conversión de discusións en fíos privados; máis adiante, este capítulo trata completamente sobre a configuración do software de comunicacións para que faga por ti tanto traballo como for posible. Polo tanto, se o software de administración ofrece unha maneira automatizada para evitar que se establezan discusións na lista, deberías pensar que activar esa opción é a decisión obvia.

Ou talvez non tanto. Existe esa utilidade, mais presenta algunhas desvantaxes realmente importantes. A cuestión de se usala ou non constitúe un dos debates máis quentes no mundo da xestión de listas&mdash;admitámolo, non unha controversia como para saír nas noticias da noite na túa cidade, mais si que pode xurdir de tempo en tempo en todo proxecto de software libre. Máis adiante describirei esta utilidade, darei os principais argumentos a favor e en contra, e darei a mellor recomendación que poida.

A utilidade en si mesma é moi simple: o software de listas de correo pode, se ti queres, configurar automaticamente o cabezallo "responder-a" (Reply-to) en todas as mensaxes, de xeito que as respostas se encamiñen á propia lista. Isto é, independentemente do que o remitente poña no cabezallo "contestar a "(e mesmo se non poñen nada en absoluto), cando os subscritores vexan a mensaxe, o cabezallo conterá o enderezo da lista:

Responder a: discusións@listas.exemplo.org

De primeiras, parece unha boa idea. Xa que practicamente todo o software de lectura de correo ten en conta o cabezallo "responder a", cando alguén responder a unha mensaxe, a súa resposta vai ser automaticamente dirixida a toda a lista, non só ao remitente da mensaxe orixinal. Por suposto, quen contesta pode mudar manualmente o destinatario da súa mensaxe, mais o importante é que <emphasis>por defecto</emphasis> as respostas son dirixidas á lista. É un exemplo perfecto do uso da tecnoloxía para fomentar a colaboración.

Infelizmente, hai algunhas desvantaxes. A primeira é coñecida como o problema de <firstterm>Non podo dar co camiño de volta</firstterm>: ás veces o remitente pon o seu enderezo "real" de correo electrónico no cabezallo "responder a", porque por unha razón ou outra envía o seu correo desde un enderezo distinto de onde o recibe. A xente que sempre envía a recibe o seu correo desde o mesmo enderezo non ten este problema, e pode que se sorprenda mesmo de que exista. Mais para aqueles que teñen configuracións de coreo inusitadas, ou que non poden controlar que enderezo ocupa o campo "de" das súas mensaxes (talvez porque envían os correos desde o seu traballo e non teñen influencia ningunha sobre o seu departamento de TI), usar o "responder a" pode ser a única maneira de asegurar que lles chegan as respostas. Cando alguén así publica algunha mensaxe nunha lista á que non está subscrito, a súa configuración do "responder a" tórnase unha información esencial. Se o software da lista sobrescribe esa información, é posible que nunca chegue a ver as respostas á súa mensaxe.

A segunda desvantaxe ten a ver coas expectativas, e na miña opinión é o argumento máis poderoso contra o uso de forzar o "responder a". Os usuarios de correo electrónico máis experimentados están afeitos a dous métodos básicos de resposta:<firstterm>"responder a todos"</firstterm> e <firstterm>"responder ao remitente"</firstterm>. Todos os programas de lectura de correo electrónico modernos teñen botóns diferentes para estas dúas accións. Os usuarios saben que para responder a todo o mundo (incluíndo a lista) deben escoller "responder a todos", e para responder en privado ao autor orixinal, deben escoller "responder ao remitente". Aínda que desexes fomentar que a xente responda á lista sempre que for posible, hai certas circunstancias nas que a resposta privada é unha decisión de quen responde&mdash;por exemplo, poden querer dicirlle algo confidencial ao autor da mensaxe inicial, algo que resultaría inapropiado publicar na lista.

E agora considera o que pasa cando a lista sobrescribe o "responder a" do remitente orixinal. Quen responde pulsa a tecla de "responder ao remitente", esperando que a mensaxe lle sexa enviada directamente ao autor orixinal. Xa que ese é o comportamento esperado, pode que non se preocupe de comprobar o enderezo do destinatario na nova mensaxe. Compón a súa mensaxe privada e confidencial, que quizais conteña cousas embarazosas sobre alguén da lista, e preme a tecla de enviar. De súpeto, poucos minutos máis tarde, a mensaxe aparece <emphasis>na lista!</emphasis>. Certo, en teoría el tiña que ter comprobado convenientemente o que puña no campo "destinatario", e moitos usuarios expertos esperan que se faga así. De feito, cando alguén configura o "responder a" con calquera outro enderezo, como a da lista, xeralmente ten o coidado de mencionar este feito no corpo da mensaxe, de xeito que a xente non se sorprenda do que pasa cando responden.

Como resultado das consecuencias deste comportamento inesperado, a miña preferencia pasa por configurar o software de xestión da lista de xeito que nunca toque o cabezallo "responder a". Esta é unha das ocasións nas que usar a tecnoloxía para fomentar a colaboración ten, paréceme, efectos colaterais potencialmente perniciosos. En calquera caso, hai tamén algúns argumentos poderosos a favor do outro bando deste debate. Independentemente do que decidas, recibirás de cando en vez mensaxes de xente preguntando por que non o escolles a outra maneira. Como seguramente non queres que esta cuestión se converta no principal fío da lista, sería bo que tiveses preparada unha resposta por anticipado, das do tipo que conducen ao abandono da discusión, en lugar de fomentala. Debes estar seguro de que <emphasis>non</emphasis> insistes en que a túa decisión, sexa esta a que for, é a única correcta (aínda que o penses). Pola contra, explica que este é un debate moi vello, que hai boas razóns nos dous bandos, que ningunha escolla vai satisfacer a todos os usuarios, e que por tanto tomaches a mellor decisión posible. Moi amablemente indica que non se debe reiniciar a discusión sobre a materia salvo que alguén tiver algo realmente novo que dicir, despois mantente á marxe do fío e espera a que morra de morte natural.

Alguén pode suxerir que se faga unha votación para decidir unha solución ou a outra. Podes facelo se quixeres, mais persoalmente non me parece que contar cabezas sexa unha boa maneira de resolver a cuestión. O castigo para quen é sorprendido polo comportamento do software da lista (enviando por accidente unha mensaxe privada á lista) é tan grande, e os inconvenientes para os demais son tan leves (tendo que recordarlle de tanto en tanto a alguén que responda á lista en troca de ao teu enderezo privado), que non está claro que a maioría, aínda que sexa precisamente maioría, poida poñer a minoría en tal risco.

Non estou a tratar aquí todos os aspectos do asunto, tan só aqueles que semellan ser da maior importancia. Para un tratamento máis completo, le estes dous documentos canónicos, que son os que sempre se citan cando xorde este debate:

<emphasis role="bold">Leave Reply-to alone</emphasis>, <emphasis>by Chip Rosenthal</emphasis>

<emphasis role="bold">Set Reply-to to list</emphasis>, <emphasis>by Simon Hill</emphasis>

Apesar da miña lixeira preferencia indicada antes, non creo que haxa unha única resposta "correcta" para esta cuestión, e de feito participo en moitas listas que escolleron <emphasis>empregar</emphasis> o "responder a". O mellor que podes facer é decidirte por unha ou outra solución o antes posible, e tratar de non enredarte en debates sobre o tema máis adiante.

Dúas fantasías

Algún día, alguén vai ter a feliz idea de implementar unha tecla <firstterm>"responder á lista"</firstterm> no seu software de correo electrónico. Empregará algún dos cabezallos estándar mencionados anteriormente para deducir o enderezo da lista, e entón dirixir as respostas tan só á lista, deixando de lado todas os demais enderezos dos destinatarios, xa que os máis deles estarán, de todos modos, subscritos. É posible que outros programas de correo copien a idea, e todo este debate desapareza finalmente. (De feito, o programa <ulink url="http://www.mutt.org/">Mutt</ulink> ofrece xa esta característica.<footnote><para>Pouco despois de que este libro fora publicado, <ulink url="http://www.michaelbernstein.com/">Michael Bernstein</ulink> escribiume para dicirme: "Hai outros programas de correo que incorporan una función de "responder á lista" ademais de Mutt. Por exemplo, Evolution ten esta función en forma de atallo de teclas, aínda que non cun botón (Ctrl+L)."</para></footnote>)

Unha solución aínda mellor sería que a opción de "responder a" estivese da parte de quen resposta. Aqueles que desexan que a lista teña o "responder a" preconfigurado (ben nas mensaxes dos outros ou nas propias) poderían escoller esta opción, e os demais escollerían que o "responder a" fose escollido por casa usuario. Porén, non coñezo ningún programa que o faga. De momento, parece que estamos estancados na opción da solución global.

Desde que escribín o anterior, descubrín que hai polo menos un sistema de xestión de listas que ofrece esta posibilidade: <ulink url="http://siesta.unixbeard.net/">Siesta</ulink>. Tamén podes ler este artigo: <ulink url="http://www.perl.com/pub/a/2004/02/05/siesta.html"></ulink>

<title>Arquivamento</title>

Os detalles técnicos acerca da configuración do arquivamento de listas de correo son específicos do software que xestiona a lista, e ultrapasan o ámbito deste libro. Cando escollas ou configures un arquivador, ten en conta as seguintes características:

Actualización áxil

Frecuentemente a xente vai querer referirse a unha mensaxe enviada durante as últimas dúas horas. Se for posible, o arquivador debería almacenar cada mensaxe instantaneamente, de xeito que en canto aparece na lista de correo estea xa dispoñible nos arquivos da mesma. Se esa opción non estiver dispoñible, entón tenta cando menos configurar o arquivador para que se actualice cada hora. Por defecto, algúns arquivadores lanzan os seus procesos de actualización unha vez cada noite, mais iso supón unha demora claramente inasumible para unha lista de correo medianamente activa.

Estabilidade referencial

Cando unha mensaxe é arquivada nunha URL dada, debería permanecer accesible para sempre nese mesmo enderezo, ou durante tanto tempo como for posible. Mesmo se os arquivos son reconstruídos, restaurados desde un ficheiro de respaldo (backup), ou reparados de calquera outra maneira, as URL que foran publicamente accesibles nun momento dado deben permanecer accesibles. As referencias estables fan posible que os motores de procura en Internet indexen correctamente os arquivos, o que supón unha vantaxe considerable para usuarios que buscan respostas a preguntas concretas. As estabilidade das referencias é tamén importante porque as mensaxes e fíos das listas de correo acostuman estar enlazadas ao xestor de erros (bug tracker) (véxase <xref linkend="bug-tracker"/><phrase output="printed"> máis adiante neste capítulo</phrase>) ou a outros documentos do proxecto.

Idealmente, o software de listas de correo debería incluir a URL do arquivo de mensaxes, ou polo menos a parte específica da URL que se refire á mensaxe, nun cabezallo, cando distribúa as mensaxes aos seus destinatarios. Deste xeito, a xente que ten unha copia da mensaxe coñecerá a localización do seu arquivo sen ter que ver realmente os arquivos, o que é moi útil porque calquera operación que implica o uso do navegador de Internet supón necesariamente un certo consumo de tempo. Non sei se todo o software de listas de correo ofrece esta característica; infelizmente, os que eu teño usado non o fan. Porén, é algo sobre o que pesquisar (ou, se escribires software para listas de correo, é unha característica que deberías considerar implementar, por favor)

Copias de seguridade (Backups)

Como facer copias de seguridade dos arquivos debería ser razoablemente obvio, e a receita de restauración non debería ser moi difícil. Noutras palabras, non trates o teu arquivador como unha caixa negra. Ti (ou alguén do teu proxecto) deberías saber onde se almacenan as mensaxes, e como rexenerar as páxinas de arquivamento desde o almacén de mensaxes no caso de que nalgún momento fose necesario. Eses arquivos conteñen datos preciosos&mdash;un proxecto que os perde, perde tamén unha parte considerable da súa memoria colectiva.

Soporte aos fíos (Threads)

Debería ser posible ir dunha mensaxe dada ao correspondente <firstterm>fío</firstterm> (grupo de mensaxes relacionadas entre si) ao que pertence esa mensaxe en particular. Cada fío debería tamén ter a súa propia URL, distinta das correspondentes ás mensaxes que compoñen o fío.

Pesquisas

Un arquivador que non soporte pesquisas&mdash;sobre os corpos das mensaxes, e sobre os seus autores ou asuntos&mdash;é cáseque inútil. Ten en conta que algúns arquivadores soportan pesquisas simplemente derivándoas a un motor externo tal como <ulink url="http://www.google.com/">Google</ulink>. Isto é aceptable, mais o soporte a pesquisas directas normalmente permite un mellor afinado, xa que deixa que a ferramenta de procura especifique que o resultado debe procurarse na liña de asunto e non no corpo, por exemplo.

O que antecede é simplemente unha lista de control para axudarte a avaliar e configurar un arquivador. Conseguir que a xente faga un <emphasis>uso</emphasis> real do arquivador en beneficio do proxecto se discute en capítulos posteriores, nomeadamente en <xref linkend="usando-arquivos"/>.

Software

De seguido se comentan algunhas ferramentas de software libre para a xestión e o arquivamento de listas de correo. Se o sitio no que tes o teu proxecto aloxado ten xa unha configuración por defecto, non vas ter que escoller ningunha ferramenta en particular. Mais si vas ter que instalar unha por ti mesmo, estas son algunhas das posibles. As que eu teño usado son Mailman, Ezmlm, MHonArc, e Hypermail, mais iso non quere decir que non haxa outras igual de boas ( e seguro que existen por aí adiante outras ferramentas que eu nin sequera dei atopado, así que non penses que esta é unha lista completa).

Software de xestión de listas de correo:

<emphasis role="bold">Mailman</emphasis>&nbsp;&mdash;&nbsp;<ulink url="http://www.list.org/"></ulink>

(Ten un arquivador incorporado, así como conexións para arquivadores externos)

<emphasis role="bold">SmartList</emphasis>&nbsp;&mdash;&nbsp;<ulink url="http://www.procmail.org/"></ulink>

(Deseñado para ser usado co sistema de procesamento de correo electrónico Procmail)

<emphasis role="bold">Ecartis</emphasis>&nbsp;&mdash;&nbsp;<ulink url="http://www.ecartis.org/"></ulink>

<emphasis role="bold">ListProc</emphasis>&nbsp;&mdash;&nbsp;<ulink url="http://listproc.sourceforge.net/"></ulink>

<emphasis role="bold">Ezmlm</emphasis>&nbsp;&mdash;&nbsp;<ulink url="http://cr.yp.to/ezmlm.html"></ulink>

(Deseñado para traballar co sistema de distribución de correo  <ulink url="http://cr.yp.to/qmail.html">Qmail</ulink>)

<emphasis role="bold">Dada</emphasis>&nbsp;&mdash;&nbsp;<ulink url="http://mojo.skazat.com/"></ulink>

(Embora os insistentes esforzos da súa web para ocultalo, é software libre, liberado baixo a licencia GNU. Tamén inclúe un arquivador)

Software de arquivamento de listas de correo:

<emphasis role="bold">MHonArc</emphasis>&nbsp;&mdash;&nbsp;<ulink url="http://www.mhonarc.org/"></ulink>

<emphasis role="bold">Hypermail</emphasis>&nbsp;&mdash;&nbsp;<ulink url="http://www.hypermail.org/"></ulink>

<emphasis role="bold">Lurker</emphasis>&nbsp;&mdash;&nbsp;<ulink url="http://sourceforge.net/projects/lurker/"></ulink>

<emphasis role="bold">Procmail</emphasis>&nbsp;&mdash;&nbsp;<ulink url="http://www.procmail.org/"></ulink>

(Software de acompañamento de Smartlistk, é un sistema procesador de correo que pode, aparentemente, ser configurado como arquivador)

Control de versións

Un <firstterm>sistema de control de versións</firstterm> (ou <firstterm>sistema de control de revisións</firstterm>) é unha combinación de tecnoloxías e prácticas para facer seguimento e control das mudanzas que se van producindo nos ficheiros dun proxecto, nomeadamente nos de código fonte, documentación e páxinas web. Se nunca antes usaches control de versións, o primeiro que deberías facer é buscar alguén que si o teña usado e fichalo para o teu proxecto. Hoxe en día, todo o mundo espera que cando menos o código fonte do teu proxecto estea subido a un sistema de control de versións, e seguramente non se tomará o proxecto en serio se non se utiliza este sistema cun mínimo de solvencia.

A razón pola que o control de versións é tan universal é que axuda a practicamente todos e cada un dos aspectos relacionados coa xestión dun proxecto: comunicacións entre desenvolvedores, xestión de liberacións, seguimento de erros (bug tracking), estabilidade do código e esforzos de desenvolvemento experimental, e atribución e autorización de mudanzas por certos desenvolvedores. O sistema de control de versións ofrece un centro de mando para todas estas tarefas. O núcleo do control de versións reside na <firstterm>xestión de mudanzas</firstterm>: identificando cada mudanza concreta realizada aos ficheiros do proxecto, anotando cada mudanza con metadatos tales como a súa data e o seu autor, e repetindo estes procesos para quen o solicitar, sen importar como. É un mecanismo de comunicación no que a mudanza é a unidade básica de información.

Esta sección non vai revisar a totalidade dos aspectos derivados do uso dun sistema de control de versións. É tan transversal que vai ser comentado ao longo do libro. Aquí concentrarémonos na escolla e a configuración dun sistema de control de versións de xeito que facilite o desenvolvemento cooperativo durante a existencia do proxecto.

Vocabulario do control de versións

Este libro non pode aprenderte a usares o control de versións se nunca antes o usaches, mais sería imposible falar sobre a materia sen definirmos primeiro algúns conceptos chave. Estes termos son útiles independentemente do sistema  de control de versións seleccionado: son os verbos e substantivos básicos da colaboración en rede, e serán usados de xeito xenérico ao longo da obra. Aínda que non existisen sistemas de control de versións, o problema da xestión de mudanzas persistiría, e estes termos vannos fornecer unha linguaxe para falar concisamente deste problema.

commit

Facer unha mudanza no proxecto; máis formalmente, almacenar unha mudanza na base de datos de control de versións de tal xeito que poida ser incorporada en futuras versións do proxecto. En inglés, "commit" pode ser usado como substantivo ou como verbo. Como substantivo, pode ser considerado como sinónimo de "mudanza". En galego a forma verbal pode ser substituída por "facer un commit". Por exemplo: "fixen o commit dun remendo para o fallo de servidores en Mac OS X que os de xestión de erros estaban a comentar. Jay, poderías revisar a mudanza e comprobar que non estou a facer mal uso do localizador (allocator)?"

mensaxe de log&nbsp;

Un pequeno comentario engadido a cada commit, describindo a natureza e o propósito da mudanza. As mensaxes de log cóntanse entre os documentos máis importantes dun proxecto: constitúen a ponte entre a linguaxe altamente técnica das mudanzas no código e a máis orientada aos usuarios de características, remendo de erros e progreso do proxecto. Máis adiante nesta sección, falaremos de como distribuír as mensaxes de log ás audiencias apropiadas; tamén, <xref linkend="codifying-tradition"/><phrase output="printed"> en <xref linkend="communications"/></phrase> se discute acerca dos modos en que os contribuíntes deben escribir mensaxes de log sinxelas e útiles.

actualizar (update)

Solicitar que as mudanzas (commits) feitas por outros se incorporen á túa copia local do proxecto; isto é, actualizar a túa copia. É unha operación moi frecuente; os máis dos desenvolvedores actualizan o seu código varias veces ao longo do día, de xeito que están seguros de estar traballando sobre cáseque o mesmo código sobre o que están a traballar os outros colaboradores, e se eles atopan un erro, poden estar bastante seguros de que aínda non foi reparado. Por exemplo: "Ei!, decateime de que o código de indexación perde o último byte constantemente. Trátase dun novo erro?" "Si, mais foi corrixido hai unha semana&mdash;tenta facer unha actualización, debería solucionarse."

repositorio

Unha base de datos na que se almacenan as mudanzas. Algúns sistemas de control de versións están centralizados: hai un único repositorio no que se almacenan todos as mudanzas do proxecto. Outros son descentralizados: cada desenvolvedor garda o seu propio repositorio, e as mudanzas poden ser trocadas entre repositorios arbitrariamente. O sistema de control de versións mantén o seguimento das dependencias entre mudanzas, e cando chega a hora de liberar unha nova versión, un conxunto concreto de mudanzas é aprobado para esa versión. A cuestión sobre se é mellor a centralización ou a descentralización é unha das guerras santas máis longas do desenvolvemento de software; tenta non caer na trampa de discutires sobre este asunto nas listas de correo do teu proxecto.

checkout

O proceso de descarregar unha copia do proxecto desde un repositorio. Un checkout xera normalmente unha árbore de directorios chamada "copia de traballo" (ver debaixo), desde a que as mudanzas poden ser enviadas novamente ao repositorio orixinal. Nalgúns sistemas de control de versións descentralizados, cada copia de traballo é ao tempo un repositorio, e as mudanzas poden ser enviadas (ou traídas de) calquera outro repositorio que as acepte.

copia de traballo

A árbore de directorios dun desenvolvedor que contén os ficheiros de código fonte e, posiblemente, as súas páxinas web ou outros documentos. Unha copia de traballo contén tamén un certo número de metadatos xeridos polo sistema de control de versións, que lle din de que repositorio vén, que "revisións" (ver máis abaixo) contén, etc. Xeralmente, cada desenvolvedor mantén a súa propia copia de traballo, na que fai e comproba as mudanzas, e desde a que fai os commits.

<firstterm>conxunto de mudanzas(changeset) </firstterm>, <firstterm>mudanza</firstterm>, <firstterm>revisión</firstterm>

Unha "revisión" é xeralmente a encarnación dun ficheiro ou directorio en particular. Por exemplo, se o proxecto comeza coa revisión 6 do ficheiro F, e despois alguén fai un commit cunha mudanza a F, isto produce a revisión 7 de F. Algúns sistemas usan tamén "revisión", "mudanza" ou "changeset" para se referiren a un conxunto de mudanzas subidas todas xuntas nun único commit como unha unidade conceptual

Estes termos teñen ocasionalmente diferentes significados técnicos en diferentes sistemas de control de versións, mais a idea máis estendida é sempre a mesma: son a maneira de falar con precisión acerca de puntos temporais concretos na historia dun ficheiro ou un conxunto de ficheiros (digamos, inmediatamente antes e despois de que un erro é reparado). Por exemplo: "ó, si, reparou ese problema na revisión 10" ou "reparou iso na revisión 10 de foo.c"

Cando un fala sobre un ficheiro ou colección de ficheiros sen especificar unha revisión en particular, xeralmente se asume que se está a referir a(s) revisión(s) máis recentes.

"Versión" fronte a "Revisión"

A palabra <firstterm>versión</firstterm> ás veces é usada como sinónimo de "revisión", mais eu non o vou usar nese sentido neste libro, porque é demasiado fácil confundilo co termo "versión" tal como cando se fala de versións dun software&mdash;isto é, o número de liberación ou distribución, como en "Versión 1.0". De todos os xeitos, como a expresión "control de versións" é de feito estándar, eu vou continuar a empregala como sinónimo de "control de revisión" e "control de mudanzas".

diff

Representación textual dunha mudanza. Un "diff" mostra que liñas foron mudadas e como, ademais dunhas poucas liñas de contextualización desa información. Un desenvolvedor que estea familiarizado cun código dado, poderá ler o diff comparándoo co código e entender que foi o que se mudou, e mesmo localizar erros.

<firstterm>etiqueta (tag)</firstterm>

Designan coleccións particulares de ficheiros pertencentes a unha revisión específica. As etiquetas xeralmente son usadas para preservar fitos interesantes dun proxecto. Por exemplo, frecuentemente se lle adxudica unha etiqueta a cada versión liberada, de tal xeito que se poida obter, directamente dende o sistema de control de versións, o conxunto exacto de ficheiros que compoñen esa versión. Os nomes que se acostuman empregar para as etiquetas poden ser do estilo de: <literal>Versión_1_0</literal>, <literal>Distribución_00456</literal>, etc.

rama (branch)

Unha copia do proxecto, baixo o control de versións mais individualizada, tal que as mudanzas feitas á rama non afectan ao resto do proxecto, e viceversa, excepto cando as mudanzas son fusionadas (merged) desde unha rama a outra (ver debaixo). As ramas son tamén coñecidas como "liñas de desenvolvemento". Mesmo cando un proxecto non ten ramas, considérase que o desenvovemento se está a facer na "rama principal (main branch)", tamén coñecida como "liña principal (main line)" ou" <firstterm>tronco (trunk)</firstterm>".

As ramas ofrecen unha maneira de isolar entre si diferentes liñas de desenvolvemento que poderían desestabilizar o tronco principal. Ou alternativamente, unha rama pode ser empregada para estabilizar unha nova versión. Durante o proceso de liberación, o desenvolvemento normal do proxecto pode continuar na rama principal do repositorio; mentres tanto, na rama da liberación, non se permite introducir novas mudanzas distintas das aprobadas polos xestores da liberación. Así, facer unha liberación non ter por que interferir cos traballos de desenvolvemento. Podes consultar <xref linkend="ramas (branches)"/><phrase output="printed"> máis adiante neste capítulo</phrase> se precisares máis detalles sobre a creación de ramas.

fusionar ("merge", ou "port")

Trasladar unha mudanza entre ramas. Inclúe fusionar desde o tronco principal a unha rama ou viceversa. De feito, estas son precisamente as fusións máis frecuentes; é raro facer fusións entre ramas secundarias do proxecto. Podes ver máis información sobre este  tema en <xref linkend="vc-singularity"/>.

"Fusionar (merge)" ten un segundo significado, relacionado co anterior: é o que fai o sistema de control de versións cando detecta que dúas persoas fixeron mudanzas a un mesmo ficheiro, mais en aspectos que non se sobrepoñen. Dado que as dúas mudanzas non interfiren entre si, cando un dos desenvolvedores actualiza a súa copia do ficheiro (contendo aínda as súas propias mudanzas), as mudanzas feitas polo segundo desenvolvedor fusiónanse automaticamente cos anteriores. Isto é moi frecuente, especialmente en proxectos nos que moitas persoas están traballando sobre o mesmo código. Cando dúas mudanzas diferentes <emphasis>interfiren</emphasis>, o resultado é un "conflicto".

conflicto

É o que sucede cando dúas persoas tratan de facer mudanzas diferentes sobre a mesma porción de código. Todos os sistemas de control de versións detectan automaticamente os conflitos, e lle notifican a cando menos un dos desenvolvedores implicados que as súas mudanzas entran en conflito coas de alguén máis. <firstterm>Resolver</firstterm> o conflicto e comunicarllo ao sistema fica entón na man desa persoa.

bloquear (lock)

É unha maneira de declarar un intento de introducir mudanzas en exclusiva nun ficheiro ou directorio dado. Por exemplo: "Non podo subir ningunha mudanza ás páxinas web neste momento. Alfred as ten bloqueadas mentres corrixe as imaxes do fondo". Non todos os sistemas de control de versións ofrecen a posibilidade de facer bloqueos, e entre os que si o fan, non todos esixen que se empregue o bloqueo. Isto é así porque o desenvolvemento simultáneo e en paralelo é a norma, e bloquear a xente que pretende traballar sobre os ficheiros é (xeralmente) contrario a este ideal.

Os sistemas de control de versións que requiren do uso do bloqueo para poder subir cambios son coñecidos como modelos do tipo <firstterm>bloqueo-modificación-desbloqueo</firstterm>. Os que non, son denominados modelos <firstterm>copia-modificación-refundido</firstterm>. Unha comparación excelente entre os dous modelos pode ser consultada en <ulink url="http://svnbook.red-bean.com/svnbook-1.0/ch02s02.html"></ulink>. En xeral, o modelo copia-modificación-refundido se considera mellor para o desenvolvemento de software libre, e todos os sistemas de control de versións que se comentan neste libro soportan o dito modelo.

Seleccionando un sistema de control de versións

Cando este libro foi escrito, os dous sistemas de control de versións máis populares no mundo do software libre eran <firstterm>Concurrent Versions System</firstterm> (<firstterm>CVS</firstterm>, <ulink url="http://www.cvshome.org/"></ulink>) e <firstterm>Subversion</firstterm> (<firstterm>SVN</firstterm>, <ulink url="http://subversion.tigris.org/"></ulink>).

CVS está dispoñible desde hai moito tempo. Os desenvolvedores máis experimentados están familiarizados dabondo con el, fai máis ou menos o que precisas, e como é popular dende hai tempo, probablemente non teñas que enredarte en longas discusións sobre se é ou non a opción máis axeitada. Porén, CVS tamén ten algunhas desvantaxes. Non subministra unha maneira doada de tratar cen mudanzas multi-ficheiro; non te deixa renomear ou copiar os ficheiros dentro do sistema de control (así que tentar reorganizar a árbore do código do teu proxecto, unha vez xa iniciado, pode tornarse nun auténtico pesadelo); o seu soporte para as fusións é moi pobre; non manexa nada ben os ficheiros moi grandes ou os binarios; e algunhas operacións son moi lentas cando se fan sobre un número grande de ficheiros.

Ningún dos fallos de CVS é fatal, e aínda é moi popular. Porén, nos últimos anos o máis recente Subversion está a gañar terreo, especialmente nos proxectos máis novos. <footnote><para>Véxase <ulink url="http://cia.vc/stats/vcs"></ulink> e <ulink url="http://subversion.tigris.org/svn-dav-securityspace-survey.html"></ulink> onde se comentan probas deste crecemento.</para></footnote>. Se estás iniciando un proxecto novo, eu recoméndoche Subversion

Pola contra, dado que eu estou participando no proxecto Subversion, a miña obxectividade pode ser razoablemente discutida. E nos últimos anos teñen xurdido un certo número de novos sistemas de control de versións en software libre. En <xref linkend="vc-systems"/>,presento unha listaxe , ordenadas máis ou menos por orde de popularidade. Como a listaxe deixa claro, decidirse por un sistema de control de versións podería tornarse nun proxecto vitalicio en si mesmo. Posiblemente vaste ver liberado desta decisión porque o fará por ti o sitio no que teñas hospedado o teu proxecto. Mais se es ti quen ten que tomar a decisión, consúltao co resto dos desenvolvedores, investiga que experiencia teñen ao respecto, e despois escolle un sistema e traballa con el. Calquera sistema de control de versións estable e listo para a produción vai satisfacer as túas necesidades; non deberías preocuparte moito sobre se tomaches unha decisión radicalmente errónea. Se simplemente non dás tomado unha decisión, entón elixe Subversion. É moi doado de aprender, e seguramente vai seguir sendo un estándar por moitos anos.

Usando o sistema de control de versións

As recomendacións desta sección non se dirixen a un sistema de control de versións en particular, e deberían ser doadas de poñer en práctica en calquera deles. Consulta a documentación do teu sistema específico se precisares máis detalles.

Versiona todo.

Debes manter no teu sistema de control de versións non só o código fonte do teu proxecto, senón tamén as súas páxinas web, documentación, FAQ, notas de deseño, e calquera outra cousa que a xente poida querer editar. Mantenas xusto a carón do código, na mesma árbore do repositorio. Calquera peza de información que pague a pena escribir, paga igualmente a pena versionar&mdash;isto é, calquera peza de información que poida ser modificada. As cousas que non están sometidas a mudanzas deberían ser arquivadas, non versionadas. Por exemplo, un email, unha vez enviado, non vai mudar; polo tanto, non tería sentido pensar en que pode ser versionado (a non ser que forme parte dun documento máis longo e que si evolúa no tempo).

A razón pola que é importante versionar todo nun único sitio é que deste xeito a xente soamente terá que aprender un mecanismo para incorporar mudanzas. Frecuentemente, un colaborador vai comezar por enviar mudanzas ás páxinas web ou á documentación, e comezará máis tarde a facer pequenas contribucións ao código, por exemplo. Cando o proxecto emprega o mesmo sistema para todos os tipos de contribucións, a xente só terá que afacerse a el unha vez. Manter todas as versións xuntas significa tamén que as novas características poden ser incorporadas xunto coa súa documentación, e que distribuír o código por varias ramas vai supor que a documentación tamén se distribúe, etc.

Non manteñas <firstterm>os ficheiros xerados</firstterm> no sistema de control de versións. Non son propiamente datos editables, xa que son xerados automaticamente a partir de outros ficheiros. Por exemplo, algúns sistemas de montaxe (build) crean o ficheiro <filename>configure</filename> a partir do molde <filename>configure.in</filename>. Para facer unha mudanza a <filename>configure</filename>, terías que editar <filename>configure.in</filename> e posteriormente rexenerar o primeiro; así, tan só o molde <filename>configure.in</filename> é un ficheiro "editable". Polo tanto, mantén no control de versións tan só os moldes&mdash;se inclúes os ficheiros resultantes, a xente vai inevitablemente esquecer rexeneralos cando incorporaren unha mudanza a un molde, e a correspondente falta de cohesión non vai causar máis que confusión.

Mais se quixeres ler unha segunda opinión acerca da cuestión dos ficheiros <filename>configure</filename>,podes revisar o comentario de Alexey Makhotkin "<citetitle>configure.in and version control</citetitle>" en <ulink url="http://versioncontrolblog.com/2007/01/08/configurein-and-version-control/"></ulink>.

A regra de que todo dato editable debe ser mantido nun sistema de control de versións ten infelizmente unha excepción: o xestor de erros (bug tracker). As bases de datos de erros conteñen multitude de datos editables, mais por cuestións técnicas non se pode, xeralmente, ter eses datos almacenados nun sistema de control de versións. (Algúns xestores de erros incorporan de seu algunhas funcionalidades moi primitivas de control de versións, mais en calquera caso independentes do repositorio principal do proxecto).

Navegabilidade

O repositorio do proxecto debe ser navegable desde a web. Isto inclúe non só a habilidade para ver a última revisión dos ficheiros do proxecto, senón tamén poder ir atrás no tempo e visitar revisións anteriores, ver as diferencias entre elas, ler as mensaxes de seguimento (log) de mudanzas concretas, etc.

A navegabilidade é importante porque supón o uso dun portal lixeiro de acceso aos datos do proxecto. Se o repositorio non pode ser visitado desde un navegador web, entón alguén que pretenda ver un ficheiro en particular (nomeadamente: comprobar se unha corrección dun erro foi xa incorporada ao código), primeiro tería que instalar localmente un cliente do sistema de control de versións, o que podería tornar a súa tarefa inicial de un par de minutos nun traballo de polo menos media hora.

Implica tamén a existencia de URL normalizadas para acceder a revisións específicas dos ficheiros, e para visitar a última revisión nun momento dado. Isto pode ser moi útil cara a discusións técnicas ou cando se trata de dirixir a xente cara á documentación. Por exemplo, en troca de dicir "Para informarse sobre instrucións para reparar o servidor, diríxase ao ficheiro www/hacking.html na súa copia local", podería dicirse"Para informarse sobre instrucións para reparar o servidor, visite <emphasis>http://svn.collab.net/repos/svn/trunk/www/hacking.html</emphasis>," proporcionando unha URL que vai dirixir sempre á última revisión do ficheiro <filename>hacking.html</filename>. A URL é mellor xa que carece totalmente de ambigüidade, e evita o problema de se o destinatario ten unha copia de traballo completamente actualizada.

Algúns sistemas de control de versións incorporan mecanismos internos de navegación polo repositorio, mentres que outros empregan ferramentas de terceiros. Estas ferramentas son:<firstterm>ViewVC</firstterm> (<ulink url="http://viewvc.org/"></ulink>), <firstterm>CVSWeb</firstterm> (<ulink url="http://www.freebsd.org/projects/cvsweb.html"></ulink>), e <firstterm>WebSVN</firstterm> (<ulink url="http://websvn.tigris.org/"></ulink>). A primeira traballa sobre CVS e Subversion, a segunda só sobre CVS, e a terceira só sobre Subversion.

Mensaxes de incorporación de mudanzas (Commit emails)

Toda incorporación de mudanzas ao repositorio (commit) debería xerar unha mensaxe na que conste quen fixo a mudanza, cando a fixo, que ficheiros e directorios mudou, e en que consistiron as mudanzas. A mensaxe debería ser enviada a unha lista de correo específica, distinta das empregadas para xestionar as mensaxes dos colaboradores. Deberíase recomendar aos desenvolvedores e outras persoas interesadas que se desen de alta na lista de mensaxes de mudanzas, xa que este é o modo máis efectivo de manter o coñecemento sobre que é o que se está a facer no proxecto a respecto do código. Para alén das evidentes vantaxes técnicas da revisión entre iguais (véxase <xref linkend="revisión-do-código"/>), as mensaxes de incorporación de mudanzas axudan a crear un espírito de comunidade, xa que dotan ao proxecto dun entorno común onde a xente pode reaccionar ante os eventos (incorporación de mudanzas) que saben que están visibles tamén para os demais.

As cuestións específicas sobre a configuración de mensaxes de incorporación de mudanzas varían dependendo de cal sexa o teu sistema de control de versións, mais xeralmente hai un script ou outra clase de utilidade para facelo. Se tiveres problemas para atopala, tenta buscar na documentación por <firstterm>hooks</firstterm>, e especialmente <firstterm>post-commit hook</firstterm>, tamén chamado <firstterm>loginfo hook</firstterm> en CVS. Os "post-commit hooks" constitúen un modo xeral de lanzar tarefas automatizadas en resposta á incorporación de mudanzas. O "hook" dispárase ante a incorporación dunha mudanza en concreto, aliméntase da información acerca desa mudanza e é logo libre de usar esa información para realizar calquera outra operación&mdash; por exemplo, enviar un correo electrónico.

No caso dos sistemas de envío de mensaxes de actualización pre-empacotados, talvez queiras modificar algúns dos comportamentos por defecto:

Algúns destes sistemas non inclúen os "diff" no email, mais inclúen unha URL na que consultar as mudanzas no repositorio a través do navegador web. Aínda que achegar a URL está ben, de xeito que se pode facer referencia á mudanza máis tarde, é tamén <emphasis>moi</emphasis> importante que a mensaxe de envío da mudanza inclúa os propios diff. A lectura dos emails é parte da rutina da xente, así que se o contido das mudanzas é visible xusto no mesmo email de mudanzas, os desenvolvedores revisarán a mudanza sobre a marcha, sen abandonar o seu lector de emails. Se teñen que premer unha ligazón para poder revisalo, os máis non o farán, xa que  isto require unha nova acción en troca da continuación do que xa estaban a facer. Aínda máis, se o revisor quere preguntar algo sobre a mudanza feita, é considerablemente máis sinxelo responder á mensaxe e incluír os comentarios sobre o rexistro de diferencias directamente sobre o propio texto do que é visitar a páxina web e cortar e colar partes do rexistro no cliente de email.

(Desde logo, se o reporte de diferencias é moi grande, como no caso de que se teña engadido ao repositorio un corpo de texto completamente novo, terá sentido omitir a información do "diff" e achegar tan só a URL. Os máis dos programas de envío de correos de actualización poden facer este tipo de discriminación automática. Se o teu non pode, o mellor será manter a inclusión dos "diff" e resignarse a sufrir mensaxes ocasionalmente enormes, que eliminalos por completo. A facilidade para facer revisións e comentarios é de vital importancia para o desenvolvemento colaborativo, demasiado para deixalos de lado)

Os correos de subida de mudanzas deberían ter o cabezallo "Reply-to" dirixido á lista normal de desenvolvemento, non á de mudanzas. É dicir, cando alguén revisa unha mudanza e remite un comentario á mesma, a súa resposta debería ser automaticamente encamiñada á lista dos desenvolvedores humanos, na que normalmente se discuten os asuntos técnicos. Hai unhas cantas razóns para facelo así. Primeiro, todas as discusións técnicas deben facerse nunha única lista xa que iso é o que a xente espera que ocorra, e porque dese xeito hai un só arquivo no que facer pesquisas. En segundo lugar, talvez haxa colaboradores que non estean subscritos á lista de mudanzas. Terceiro, a lista de correo de mudanzas se autopublicita como un servizo para facer seguimento das mudanzas, non para facer seguimento das mudanzas <emphasis>e</emphasis> de discusións técnicas ocasionais. Cando un se subscribe á lista de correo de mudanzas, non se está subscribindo ademais a ningunha outra lista; enviarlles outros materiais a través da lista violaría un contrato implícito. En cuarto lugar, a xente escribe frecuentemente pequenos programas que len a lista de mudanzas e procesan os resultados (de cara á súa publicación nunha páxina web, por exemplo). Eses programas están preparados para manipular mensaxes de correo-e formatadas de forma consistente, mais non mensaxes incoherentes escritas por humanos.

Ten en conta que esta recomendación acerca da configuración do cabezallo "Reply-to" non refuta o comentado anteriormente neste capítulo acerca do <xref linkend="reply-to"/><phrase output="printed"> </phrase>. Normalmente o <emphasis>remitente</emphasis> dunha mensaxe vai considerar correcto establecer o "Reply-to". Neste caso, o remitente é o propio sistema de control de versións, e configura o "Reply-to" para indicar que o lugar apropiado para responder ás súas mensaxes é a lista de desenvolvemento, non a de mudanzas.

CIA: outro mecanismo de publicación de mudanzas (Another Change Publication Mechanism)

As mensaxes de mudanzas non son a única maneira de propagar as novas sobre as mudanzas feitas. Recentemente desenvolveuse un novo mecanismo denominado CIA (<ulink url="http://cia.navi.cx/"></ulink>). CIA é un agregador e distribuidor en tempo real de estatísticas sobre mudanzas. O uso máis popular de CIA é o de enviar notificacións de agregación de mudanzas a canais IRC, de xeito que a xente que está conectada a eses canais pode ver a incorporación das mudanzas en tempo real. Aínda que menos útil tecnicamente que as mensaxes de mudanzas, xa que os observadores poden estar conectados ao canal ou non cando aparece no IRC unha nova sobre unha mudanza, esta técnica ten unha inmensa utilidade <emphasis>social</emphasis>. A xente terá a sensación de formar parte de algo vivo e activo, e sentirá que se progresa xusto ante os seus ollos.

A maneira en que traballa consiste en que ti invocas o programa CIA de notificación desde o gancho (hook) do teu sistema de publicación de mudanzas. O notificador formata a XML a información da mudanza, e a envía como mensaxe a un servidor central (típicamente cia.navi.cx</literal>). A continuación, ese servidor distribúe a información sobre a mudanza a outros foros.

CIA pode ser configurado tamén para enviar comunicacións <ulink url="http://www.xml.com/pub/a/2002/12/18/dive-into-xml.html">RSS</ulink>. Podes consultar os detalles na documentación do proxecto en <ulink url="http://cia.navi.cx/"></ulink>.

Para ver un exemplo de CIA en acción, accede desde o teu cliente IRC a <literal>irc.freenode.net</literal>, channel <literal>#commits</literal>.

Usa as ramas para evitar gargalos

Os usuarios non expertos dos sistemas de control de versións ás veces lle teñen un certo medo á creación de ramas (branching)e á posterior fusión (merging). Trátase probablemente dun efecto colateral da popularidade dos CVS: a súa interface de creación de ramas e fusión é pouco intuitiva, de xeito que moita xente aprendeu a evitar esas operacións por completo.

Si ti es unha destas persoas, toma a decisión xa mesmo de superares eses medos e toma o tempo preciso para aprenderes como facer a creación de ramas e a fusión. Non son operacións difíciles, unha vez que estás afeito a elas, e convértense en máis e máis importantes segundo o proxecto vai incorporando máis desenvolvedores.

As ramas son valiosas xa que converten un recurso escaso &mdash;espazos de traballo no código do proxecto&mdash; nun considerablemente máis abundante. Normalmente todos os desenvolvedores traballan conxuntamente sobre unha mesma versión do software, construíndo un único castelo. Cando alguén quere engadir unha nova torreta, mais non é quen de convencer o resto de que se debería facer iso, a creación dunha rama vaille dar a oportunidade de facelo nunha esquiniña. Se o esforzo ten éxito, pode convidar os outros desenvolvedores a examinaren os resultados. Se todos estiveren de acordo en que o resultado paga a pena, entón poden dicirlle ao sistema de control de versións que mova (fusione -merge) a torreta desde a rama ao castelo principal.

É doado ver como esta habilidade axuda ao desenvolvemento colaborativo. A xente precisa da liberdade de probaren cousas novas sen sentiren que están a interferir co traballo dos demais. Igualmente importante, hai momentos en que o código precisa ser isolado das tarefas habituais, para corrixir un erro ou estabilizar unha versión para ser liberada(véxase <xref linkend="stabilizing-a-release"/> e <xref linkend="release-lines"/><phrase output="printed"> en <xref linkend="development-cycle"/></phrase>) sen ter que se preocupar acerca de manter controlada unha diana móbil.

Usa as ramas con liberalidade, e aconsella os demais a que tamén o fagan. Mais tamén debes estar seguro de que cada rama vai permanecer activa exactamente o tempo estritamente necesario. Cada rama é unha pequena fuga na atención da comunidade. Mesmo os que non están a traballar na rama manteñen un interese periférico sobre o que está a acontecer nela. Ese interese é desexable, por suposto, e deberíanse enviar correos de incorporación de mudanzas exactamente igual que no caso dos correspondentes ao corpo principal do proxecto. Mais as ramas non deben tornar nun mecanismo de división da comunidade de desenvolvemento. Salvo raras excepcións, o obxectivo final das máis das ramas debería ser o de que as súas mudanzas sexan reintegradas á liña principal e que a rama desapareza.

Singularidade da información

A fusión (merging) ten un corolario importante: nunca envíes unha mesma mudanza dúas veces. Isto é, cada mudanza dada debería ser incorporada ao sistema de control de versións exactamente unha soa vez. A revisión (ou conxunto de revisións) na que a mudanza foi incorporada será o seu identificador único de aí en diante. Se for necesario incorporala a outras ramas distintas daquela na que tivo a súa orixe, entón debería ser fusionada (merged) desde o seu punto de entrada orixinal cara a eses outros destinos&mdash;en oposición á integración dunha mudanza textualmente idéntica, que tería o mesmo efecto sobre o código, mais que tornaría imposibles o arquivamento preciso e a xestión de liberacións.

Os efectos prácticos deste consello van diferir dun sistema de control de versións a outro. Nalgúns sistemas, as fusións son acontecementos especiais, fundamentalmente diferentes da incorporación de mudanzas, e presentan o seu propio conxunto de metadatos. Noutros, o resultado das fusións é incorporado exactamente igual que calquera outra mudanza de xeito que o medio fundamental para distinguir unha "incorporación dun ha fusión" dunha "incorporación dunha mudanza" estará nos contidos da mensaxe de rexistro. Nunha mensaxe de rexistro dunha fusión nunca debes repetir a mensaxe de rexistro da mudanza orixinal. Pola contra, debes indicar tan só que se trata dunha fusión, e asígnalle o identificador de revisión da mudanza orixinal, engadindo como moito un breve resumo dos seus efectos. Se alguén quixer ver a mensaxe de rexistro completa, deberá consultar a revisión orixinal.

A razón pola que a repetición das mensaxes de rexistro é importante é que ás veces son editadas despois de enviada a mudanza. Se a mensaxe de rexistro de cada mudanza fose repetida en cada destino de fusión, entón se alguén editara a mensaxe orixinal, quedarían sen corrixir as distintas repeticións&mdash;o que simplemente causaría confusión no futuro.

O mesmo principio pode ser aplicado cando se reverte unha mudanza. No caso de que unha mudanza sexa descartada do código, a única mensaxe de rexistro que debería engadirse debería tan só especificar que unha revisión concreta está a ser descartada, <emphasis>nunca</emphasis> se debería describir a mudanza resultante desa operación, xa que a semántica da mudanza pode derivarse mediante a simple lectura da mensaxe de rexistro da mudanza orixinal. Por suposto, a mensaxe de rexistro do descarte debería igualmente deixar claro por que se decide ese descarte, mais non debería duplicar ningunha información procedente da mensaxe orixinal de rexistro. Sempre que for posible, o que si se debe facer é editar esa mensaxe orixinal para explicar nela que a mudanza á que se refire foi finalmente descartada.

Todo o que antecede implica que se debería empregar unha sintaxe coherente para referirse ás revisións. Isto non é só importante para as mensaxes de rexistro, senón tamén nas de correo electrónico, o xestor de erros (bugtracker), e en toda a documentación do proxecto. Se estás a usar CVS, suxírote "<literal>path/to/file/in/project/tree:REV</literal>", na que REV é un número de revisión concreto do CVS tal como "1.76". Se estás a empregar Subversion, a sintaxe estándar para as revisións 1729 é "r1729" (as rutas dos arquivos non son precisas xa que Subversion emprega números de revisión globais). Noutros sistemas, normalmente hai tamén unha sintaxe estándar para denominar o conxunto de mudanzas. Calquera que for a sintaxe axeitada para o teu sistema, anima a xente a usárena para referírense ás mudanzas. A expresión coherente dos nomes de mudanzas axuda a facer máis doado o arquivamento do proxecto (como veremos en <xref linkend="communicacións"/> and <xref linkend="ciclo-de-desenvolvemento"/>) e como unha boa parte do traballo de arquivamento vai ser feita por voluntarios, mellor mantelo tan simple como for posible.

Podes ver tamén <xref linkend="liberacións-e-desenvolvemento-diario"/><phrase output="printed"> en <xref linkend="ciclo-de-desenvolvemento"/></phrase>.

Autorización

Os máis dos sistemas de control de versións ofrecen unha característica pola cal determinadas persoas poden ser autorizadas ou non a introduciren mudanzas en subáreas concretas do repositorio do proxecto. Seguindo o principio de que cando agarras un martelo, a xente comeza a ollar ao redor en busca de cravos, moitos proxectos empregan esta característica con abandono, garantindo coidadosamente que a xente teña acceso a xusto aquelas áreas para as que están autorizados a subiren mudanzas, e que non poidan facelo en ningunha outra parte. (Podes consultar <xref linkend="committers"/><phrase output="printed"> en <xref linkend="xestionando-voluntarios"/></phrase> para entenderes como se decide quen vai poder introducir mudanzas en que partes do proxecto)

Probablemente haxa pouco risco de danos por exercer un control tan estrito, mais unha política máis relaxada é tamén viable. Algúns proxectos simplemente usan un sistema honorífico: cando alguén recibe autorización para acceder ao sistema de control de mudanzas, mesmo para unha subárea do repositorio, o que en realidade están a recibir é un pasaporte para poderen introducir mudanzas en calquera parte do proxecto. Simplemente se lles suxire que manteñan as súas mudanzas na súa área. Ten en conta que non existe ningún risco real en facelo así: nun proxecto activo, todos as mudanzas integradas son revisadas por alguén. Se un colaborador introducir mudanzas nunha área na que non está autorizado a traballar, outros vanse decatar e o van comentar. Se for preciso desfacer unha mudanza, chega con iso&mdash;todo está sometido ao sistema de control de versións, así que simplemente terás que reverter a mudanza.

Hai moitas vantaxes nunha aproximación relaxada. Primeiro, segundo os desenvolvedores van expandíndose por outras áreas (o que con seguridade vai ocorrer, se é que se manteñen no proxecto), non hai ningunha dificultade administrativa en ampliarlles os privilexios de acceso. Unha vez que se toma a decisión, a persoa en cuestión pode comezar inmediatamente a traballar na nova área.

Segundo, a expansión pode ser feita dun xeito máis granular. Xeralmente, un desenvolvedor da área X que queira expandir o seu interese á área Y, comezará a publicar aportamentos a Y e solicitar que sexan revisadas. Se alguén que xa tiña privilexios de acceso a Y ve unha das mencionados aportamentos e a aproba, simplemente poden indicarlle ao desenvolvedor que incorpore a mudanza directamente ao repositorio (mencionando o nome do revisor na mensaxe de rexistro ,por suposto). Así, a incorporación da mudanza vai ser feita por quen escribiu a mudanza, o que é máis axeitado tanto desde o punto de vista da xestión da información como desde o da acreditación de autorías.

Por último, e pode que sexa o máis importante, empregar un sistema meritocrático crea unha atmosfera de confianza e respecto mutuos. Darlle a alguén acceso a un subdominio é unha manifestación acerca da súa preparación técnica&mdash;é como dicir: "Ei!, xa vemos que tes experiencia como para incorporar mudanzas neste dominio, así que adiante". Pola contra, establecer un sistema moi estrito de control de accesos é como dicir: "Non só estamos poñendo en dúbida a túa experiencia, tamén temos sospeitas sobre as túas <emphasis>intencións</emphasis>." E ese é o tipo de frases que non che gustaría empregar , se é que podes evitalo. Incorporar alguén ao proxecto como desenvolvedor é unha oportunidade para inicialo no círculo de confianza mutua. Unha boa maneira de facelo é concederlle máis poder do que se lle supón que vai usar, e despois informarlles que está nas súas mans manterse dentro dos límites acordados.

O proxecto Subversion vén traballando co sistema meirotcrático desde hai máis de catro anos, con 33 colaboradores sobre a totalidade do proxecto e 43 sobre partes do mesmo cando foi escrita a presente obra. A única distinción que o sistema mantén realmente por si mesmo é entre quen pode subir mudanzas e quen non; as restantes divisións son mantidas exclusivamente por humanos. A día de hoxe non tivemos ningún problema con alguén que pretendera incorporar mudanzas fóra do seu dominio deliberadamente. Unha vez ou dúas houbo algunha falta de entendemento acerca de ata onde chegan exactamente os privilexios de alguén, mais sempre foron resoltas rápida e amigablemente.

Obviamente, en situacións nas que o autocontrol non é práctico, deberás establecer controis de autenticación severos. Mais estas situacións son pouco frecuentes. Mesmo cando se está a falar de millóns de liñas de código e centos ou milleiros de desenvolvedores, a incorporación dunha mudanza a un módulo de código concreto debería ser revisada por quen traballa nese módulo preciso, e son eles quen poden recoñecer se alguén que non debería está a enviar mudanzas. Se a revisión regular de mudanzas a incorporar <emphasis>non</emphasis> está a funcionar axeitadamente, entón é que o proxecto ten problemas máis importantes que resolver que os relativos ao sistema de autenticacións.

En resumo, non pases moito tempo chafullando no sistema de autenticación do control de versións, non sendo que teñas unha razón específica para facelo. Xeralmente non vai producir ningún beneficio tanxible e, porén, atoparás moitas vantaxes en deixar o control en mans dos humanos.

Nada do que antecede debe ser tomado no sentido de que as restricións carecen de importancia en si mesmas, por suposto. Pode ser desastroso para un proxecto deixar que a xente incorpore mudanzas en áreas para as que non están cualificados. Aínda máis, en moitos proxectos, o acceso completo (sen restricións) responde a un status especial: implica gozar do dereito a votar en cuestións que afecten a calquera das partes do proxecto. Este aspecto político dos accesos á incorporación de mudanzas é discutido máis a fondo en <xref linkend="electorado"/><phrase output="printed"> e en <xref linkend="infrastrutura-social"/></phrase>.

Xestor de erros (Bug Tracker)

A xestión de erros é unha cuestión moi ampla; varios dos aspectos que lle afectan son discutidos ao longo deste libro. Aquí eu vou tratar de concentrarme principalmente na súa configuración e máis en consideracións técnicas, mais antes de chegar a ese punto, temos que comezar cunha cuestión política: exactamente que información debe ser mantida nun xestor de erros?

O termo <firstterm>bug tracker</firstterm> é confuso. Os sistemas de xestión de erros son usados frecuentemente para facer seguimento de requirimentos de novas características, tarefas unitarias, remendos non solicitados&mdash;en realidade calquera cousa que presenta distintos estados de inicio e de fin, con estados opcionais de transición no medio, o que fai incrementar a información asociada ao longo do tempo. Por esta razón os xestores de erros son tamén denominados <firstterm>xestores de asuntos (issue trackers)</firstterm>, <firstterm>xestores de defectos (defect trackers)</firstterm>, <firstterm>xestores de artefactos (artifact trackers)</firstterm>, <firstterm>xestores de requisitos (request trackers)</firstterm>, <firstterm>sitemas de tickets de errores (trouble ticket systems)</firstterm>, etc. Podes consultar unha lista de software en<xref linkend="bug-trackers"/>.

Neste libro, eu vou continuar a falar de "xestor de erros (bug tracker)" cando me refira ao software que fai o seguimento, xa que é así como a maioría da xente lle chama, mais vou empregar <firstterm>asunto (issue)</firstterm> para referirme a unha instancia individual na base de datos do xestor de erros. Isto vainos permitir distinguir entre o comportamento ou fallo que o usuario ten atopado (isto é, o error ou "bug" en sí mesmo), e os <emphasis>rexistros</emphasis> referidos ao descubrimento, diagnose e eventual resolución do erro. Ten en conta que aínda que moitos asuntos se refiren a erros reais, tamén poden referirse igualmente ao seguimento de outros tipos de tarefas.

O clásico ciclo de vida dun asunto é semellante a:

Alguén detecta o erro. Subministra un resumo, unha breve descrición do mesmo (incluíndo unha receita para reproducir o fallo, no seu caso; bótalle unha ollada a <xref linkend="de-usuarios-a-voluntarios"/><phrase output="printed"> en <xref linkend="xestionando-voluntarios"/></phrase> para entenderes como se debe pedir á xente que faga bos informes de erros), así como calquera outra información que o xestor de erros pida. A persoa que detecta o asunto pode ser totalmente descoñecida para o proxecto&mdash;os informes sobre erros e o requirimento de novas funcionalidades terán as mesmas probabilidades de seren solicitados tanto por usuarios como polos desenvolvedores.

Unha vez reportado, o asunto fica rexistrado no estado coñecido como <firstterm>aberto</firstterm>. Como de momento non se realizou ningunha operación sobre el, algúns xestores de erros o denominan <firstterm>non verificado</firstterm> e/ou <firstterm>sen iniciar</firstterm>. Non está aínda asignado a ninguén; ou, nalgúns xestores, se lle asigna a un usuario ficticio, o que vén a representar a ausencia de asignación. Neste punto, está nun espazo de espera: o asunto foi arquivado, mais aínda non está integrado na conciencia activa do proxecto.

Outra xente vai ler o asunto, engadirlle comentarios, e talvez preguntarlle ao remitente orixinal sobre detalles que clarifiquen algún punto escuro.

O erro é entón <firstterm>reproducido</firstterm>. Este pode ser o momento máis importante no seu ciclo de vida. Aínda que o erro non está corrixido, o feito de que alguén ademais do remitente orixinal sexa quen de reproducilo vai demostrar que é auténtico, e , non menos importante, vai confirmar a quen o detectou por primeira vez que contribuíu ao proxecto cun erro real.

O erro é entón <firstterm>diagnosticado</firstterm>: identifícase a causa que o produce, e se for posible, estímase o esforzo requerido para corrixilo. Estes procesos deben ficar gravados no sistema; se a persoa que fai o diagnóstico desaparece repentinamente do proxecto por un tempo (o que vai suceder frecuentemente cos desenvolvedores voluntarios), calquera outro deberá ser quen de retomar a xestión do erro onde o outro o deixou.

Neste paso, ou ás veces no anterior, un desenvolvedor vaise "apropiar" do asunto e <firstterm>auto asignarseo</firstterm>  (<xref linkend="asignación-de-delegacións"/><phrase output="printed"> en <xref linkend="xestionando-voluntarios"/></phrase> examina o proceso con máis detalle). A <firstterm>prioridade</firstterm> pode tamén ser establecida neste paso. Por exemplo, se for tan severo que podería retrasar a seguinte liberación, ese asunto precisa ser identificado logo, e o xestor debería proporcionar algunha maneira de notificalo.

O asunto é entón programado para ser resolto. A programación non ten por que incluír a determinación dunha data límite para a súa corrección. Ás veces implica simplemente determinar en que liberación futura (non necesariamente a seguinte) o erro debería estar solucionado, ou decidir que non é preciso bloquear ningunha liberación en particular. A programación pode tamén ser ignorada, se o erro é doado de resolver.

O erro é resolto (ou a tarefa completada, ou o remendo aplicado, ou o que for). A mudanza ou conxunto de mudanzas resultantes da súa resolución deberán ser gravadas nun comentario, e posteriormente o asunto é <firstterm>pechado</firstterm> e/ou marcado como <firstterm>resolto</firstterm>.

Hai algunhas variacións frecuentes sobre este ciclo de vida. Ás veces un asunto é pechado moi cedo tras ser comunicado, porque resulta non ser realmente un erro, senón un fallo de utilización por parte do usuario. Segundo o proxecto vai tendo máis usuarios, máis de estes falsos erros van ser comunicados, e os desenvolvedores van proceder a pechalos con comentarios cada vez máis intempestivos. Tenta evitar esta última  tendencia. Non lle fai ningún ben a ninguén, xa que o usuario que comunica o erro en cada caso non é responsable do todas as comunicacións previas; a tendencia estatística é visible só desde o punto de vista dos desenvolvedores, non dos usuarios.(Máis adiante neste capítulo, en <xref linkend="filtrado-de-erros"/><phrase output="printed"> </phrase>, veremos algunhas técnicas destinadas a reducir o número de falsos erros). Igualmente, se diferentes usuarios están a cometer o mesmo fallo de operación unha e outra vez, poderíase pensar que esa parte do software precisa ser redeseñada. Este tipo de padróns son máis doados de detectar cando hai un xestor de asuntos monitorizando a base de datos de erros; véxase <xref linkend="xestor-de-asuntos"/><phrase output="printed"> en <xref linkend="xestionando-voluntarios"/></phrase>.

Outra variación frecuente do ciclo de vida consiste en pechar o asunto como <firstterm>duplicado</firstterm> xusto despois do Paso 1. Un duplicado é un asunto que xa é coñecido polos responsables do proxecto. Os duplicados non afectan exclusivamente a asuntos abertos: é posible que un erro volva manifestarse mesmo despois de ter sido resolto (isto é coñecido como <firstterm>regresión</firstterm>), en cuxo caso o procedemento preferido consiste en reabrir o asunto orixinal e pechar calquera nova notificación do mesmo como duplicados do anterior. O sistema de xestión de erros debería facer seguimento bidireccional desta relación, de xeito que a información sobre reproducción contida nos duplicados estea dispoñible para o orixinal, e viceversa.

Unha terceira variación consiste en que os desenvolvedores pechen o asunto, pensando que o resolveron, e ver que o informante orixinal rexeita a solución e o reabre. Isto xeralmente ocorre porque os desenvolvedores simplemente non teñen acceso ao entorno necesario para reproduciren o fallo, ou porque non o reproduciron seguindo exactamente a mesma receita aportada polo informante para a súa reprodución.

Para alén destas varacións, poden darse outros aspectos do xestor de erros  que poden variar dependendo do software empregado. Mais o aspecto básico é o mesmo, e mentres o ciclo de vida en sí mesmo non é especifico do software de fontes abertas, ten implicacións concretas en como os proxectos de software aberto usan os seus xestores de erros.

Tal como se deduce do Paso 1, o xestor é tan "fachada pública" do proxecto como poidan selo as listas de correo ou as páxinas web. Calquera pode rexistrar un asunto, calquera pode facer seguimento dun asunto, e calquera pode explorar a lista de asuntos actualmente abertos. Ocorre que non podes coñecer canta xente está pendente de como se resolve un asunto. Mentres que o tamaño e a habilidade da comunidade van reducir o prazo en que os asuntos son resoltos, o proxecto debería en todo caso ser quen de tomar coñecemento de cada asunto xusto no momento en que é detectado. Mesmo se un asunto permanece activo durante un tempo, unha resposta vai favorecer que o informante permaneza interesado, xa que vai notar que alguén tomou nota do que el reportou (lembra que preencher un formulario de notificación dun asunto leva máis tempo que, por exemplo, escribir un correo electrónico). Aínda máis, unha vez que un asunto é revisado por un desenvolvedor, pasa a formar parta da "consciencia" do proxecto, no senso de que ese desenvolvedor pode estar xa analizando outras instancias do asunto, pode falar sobre o tema con outros colegas, etc.

A necesidade de reaccionar a tempo implica dúas cousas:

O xestor debe estar conectado a unha lista de correo, de xeito que cada mudanza sobre un asunto, incluíndo a súa notificación inicial, debe producir unha mensaxe de correo que describa o que aconteceu. Esta lista de correo é xeralmente distinta da de desenvolvemento, xa que non todos os desenvolvedores poden querer recibir mensaxes automatizadas referidas a erros, mais (igual que nas mensaxes de inserción de cambios) o cabezallo "Reply-to" debería ser dirixido á lista xeral de desenvolvemento.

O formulario de notificación de asuntos debería capturar o enderezo de correo do remitente, de xeito que poida ser contactado para pedirlle máis información. (Porén, non debería <emphasis>requerir</emphasis> ese enderezo, dado que hai xente que prefire notificar erros de xeito anónimo. Véxase <xref linkend="confidencialidade"/><phrase output="printed"> máis adiante neste capítulo</phrase> para ler información adicional sobre a importancia de poder manter o anonimato.)

Interacción con listas de correo

Asegúrate de que o xestor de erros non se convirte nun foro de discusión. Aínda que é importante manter a presencia humana no sistema, non está preparado para soportar discusións en tempo real. Máis ben debes pensar nel como un arquivador, un xeito de organizar feitos e referencias cara a outras discusións, basicamente aquelas que teñen lugar nas listas de correo.

Hai dúas razóns para facer esta distinción. Primeiro, o xestor de erros e máis complicado de usar que as listas de correo (ou que os chats en tempo real). Isto non é así debido a que o xestor teña unha interface de usuario mal deseñada, senón a que as súas interfaces foron deseñadas para capturar e presentar estados discretos, non discusións libres. En segundo lugar, non todo o mundo que está a seguir unha determinada discusión sobre un asunto ten por que estar conectado ao xestor de erros. En parte a boa xestión de asuntos (véxase <xref linkend="xestión-compartida"/><phrase output="printed"> en <xref linkend="xestionando-voluntarios"/></phrase>) ten a ver con asegurar que a información correcta está sendo posta a disposición da xente axeitada, máis que con pretender que todos os desenvolvedores estean pendentes de todos os asuntos. En <xref linkend="uso-do-xestor-de-erros"/><phrase output="printed"> en <xref linkend="comunicacións"/>,</phrase> veremos algunhas maneiras de asegurar que a xente non lance discusións fora dos foros apropiados e no xestor de erros.

Algúns xestores de erros poden monitorizar as listas de correo e rexistrar automaticamente todas as mensaxes que teñen a ver cun asunto coñecido. Tipicamente fan isto mediante o recoñecemento do identificador do erro na liña de "asunto" das mensaxes para atraeren a atención do xestor. Este ou ben gardará toda a mensaxe, ou (aínda mellor) gravará unha ligazón á mensaxe gardada nos arquivos da lista de correo. En calquera caso, esta é unha característica moi útil; se o teu xestor dispón dela, asegúrate de activala e de recomendar á xente a súa utilización.

Pre-filtrando o xestor de erros

As máis das bases de datos de asuntos sofren de cando en vez o mesmo problema: unha cantidade crítica de asuntos duplicados ou inválidos procedentes de usuarios ben intencionados mais inexpertos ou mal informados. O primeiro paso para combater esta tendencia consiste en colgar un aviso ben visible na páxina de entrada ao xestor de erros no que se explique como saber se un erro é realmente un erro, como buscar se xa foi notificado e, finalmente, como facer correctamente a notificación se se segue a pensar que se trata realmente dun erro novo.

Ese sistema reduciría o nivel de ruído por un tempo, mais segundo aumenta o número de usuarios, o problema vai retornar. Ningún usuario individual pode ser culpado diso. Cada un deles está pretendendo contribuír ao benestar do proxecto, e mesmo se a primeira notificación do erro non é útil, deberás continuar animándoos a permaneceren involucrados e a que fagan mellores contribucións no futuro. Mentres tanto, porén, o proxecto vai precisar manter a base de datos de asuntos o máis libre de lixo posible.

As dúas cousas que mellor van contribuír a previr este problema son: estar seguro de que vai haber xente suficientemente capacitada controlando o que está a ocorrer no sistema de xestión de erros como para ser quen de pechar notificacións inválidas ou duplicadas no momento xusto en que entran, e requirir (ou recomendar fortemente) que os usuarios confirmen con outros usuarios os erros detectados por eles antes de reportalos ao sistema.

Semella que a primeira das técnicas mencionadas está a ser usada universalmente. Mesmo proxectos con bases de datos inmensas (nomeadamente, o xestor de erros de Debian en <ulink url="http://bugs.debian.org/"></ulink>, que no momento de escribir este texto contiña 315.929 asuntos <footnote><para>N. do T.: máis de 500.000 no momento de facer esta tradución</para></footnote> aínda organizan as cousas de xeito que <emphasis>alguén</emphasis> ve os asuntos que van chegando ao sistema. Pode ser unha persoa diferente para cada categoría de asuntos. Por exemplo, o proxecto Debian é unha colección de pacotes de software, así que Debian encamiña automaticamente cada novo asunto aos mantedores do correspondente pacote. Por suposto, os usuarios poden ás veces trabucarse na identificación das categorías ás que corresponden os erros detectados, co resultado de que o erro é enviado inicialmente á persoa incorrecta, quen deberá encargarse de encamiñalo novamente. De calquera maneira, o importante é que a carga de traballo é compartida, de todos modos&mdash;se o usuario tiver dúbidas no momento de reportar un asunto, a vixilancia sobre a entrada de asuntos vai estar mellor ou peor distribuída entre os desenvolvedores, de xeito que cada asunto vai recibir sempre unha resposta a tempo.

A segunda técnica está menos estendida, probablemente porque é máis difícil de automatizar. A idea esencial é que cada asunto novo é "coleguizado" na base de datos. Cando un usuario pensa que localizou un problema, solicítaselle que o describa nunha lista de correo, ou nun canal IRC, e recibe a confirmación por parte de alguén que lle di que efectivamente é un erro. Dispoñer cedo deste segundo par de ollos pode previr unha chea de reportes falsos. Ás veces, o segundo implicado é quen de identificar que o comportamento reportado non é un erro, ou que xa está corrixido nalgunha versión recente. Ou pode estar familiarizado cos síntomas dun asunto anterior, e evitar unha segunda incorporación do erro dirixindo o usuario cara ao asunto orixinal. Frecuentemente abonda con preguntarlle ao usuario: "Pesquisaches no sistema de xestión de erros se xa foi comunicado?". Moita xente simplemente nin pensa nesa posibilidade, aínda que farán a pesquisa de bo grado se saben que alguén <emphasis>espera</emphasis> que a fagan.

O sistema de colegas pode manter a base de datos de asuntos realmente limpa, mais tamén ten algunhas desvantaxes. Moita xente vai reportar en solitario, de todas maneiras, ben por non teren atopado, ou por ignoraren deliberadamente, as instrucións sobre pesquisa dun colega para reportar asuntos novos. Así que aínda vai ser necesario que haxa voluntarios revisando a base de datos. Aínda máis, como os máis dos remitentes novos non van ser conscientes da dificultade de manter a base de datos de asuntos, non é axeitado reprendelos por teren ignorado as instrucións. Así que os voluntarios van ter que permanecer atentos, e controlar como lles van devolver os asuntos non "colegueados" aos seus remitentes. O obxectivo é adestrar cada remitente no uso do sistema de colegas, de tal xeito que haxa sempre unha reserva crecente de xente que entende o sistema de filtraxe. Cando se detecta un asunto non revisado por un colega, os pasos ideais son:

Responder inmediatamente ao asunto, agradecendo amablemente o usuario por telo remitido, mais dirixíndoos as instrucións sobre revisión por terceiros (que, por suposto, deberán estar ben visibles na web do proxecto).

Se o asunto for claramente válido e non estiver duplicado, aprobádeo de todas maneiras, e iniciade o seu ciclo de vida normal. Despois de todo, o remitente xa estará informado sobre o sistema de revisión, e non ten sentido perder o tempo e o traballo feito pola vía de pechar un asunto perfectamente válido.

Pola contra, se o asunto non for claramente válido, péchao, mais pídelle ao remitente que o reabra se recibir confirmación dun colega. Cando a recibiren, deberán facer mención ao fío de confirmación (p.e.: mediante unha URL dos arquivos da lista).

Lembra que aínda que este sistema vai mellorar co tempo a relación sinal/ruído na base de datos, non vai poder evitar completamente a introdución de asuntos incorrectos. A única maneira de previr totalmente este problema é pechar o xestor de erros para todo o mundo salvo para os desenvolvedores&mdash;un remedio que é case sempre peor que a enfermidade. É mellor aceptar que a limpeza de asuntos inválidos vai constituír sempre unha tarefa máis da rutina de mantemento do proxecto, e tratar de contar co máximo número de persoas botando unha man.

Podes ver máis sobre este tema en  <xref linkend="xestor-de-asuntos"/><phrase output="printed"> en <xref linkend="xestionando-voluntarios"/></phrase>.

IRC / Sistema de comunicacións en tempo real

Moitos proxectos ofrecen salas de conversación en tempo real usando foros <firstterm>Internet Relay Chat</firstterm>(<firstterm>IRC</firstterm>) nos que usuario e desenvolvedores poden responder ás preguntas dos demais e obter respostas instantáneas. Aínda que <emphasis>poidas</emphasis> manter un servidor IRC na túa propia sede web, normalmente non paga a pena facelo. Pola contra, fai o que fai todo o mundo: establece os teus canais IRC en Freenode(<ulink url="http://freenode.net/"></ulink>). Freenode ofréceche o control que precisas para administrar os canais IRC do teu proxecto, <footnote><para>Non hai obriga nin se espera que fagas unha doazón a Freenode, mais se ti ou o teu proxecto podedes afrontalo, por favor, pensa en contribuír economicamente. están exentos de impostos nos EEUU, e están a fornecer un servizo realmente valioso.</para></footnote>

A primeira tarefa é a de buscar un nome para o canal. A elección máis obvia é a do nome do teu proxecto&mdash;se estiver dispoñible en Freenode, úsao. Se non , tenta dar con algo que se lle pareza o máis posible, e que sexa o máis doado de lembrar. Anuncia a dispoñibilidade do canal na páxina do proxecto, de xeito que un visitante que teña necesidade de facer unha pregunta urxente o atope á primeira. Por exemplo, esta mensaxe aparece nunha caixa moi ben situada na páxina de Subversion:

<blockquote> <para><emphasis>Se estás a empregar Subversion, recomendámosche que te unas á lista</emphasis> <literal>users@subversion.tigris.org</literal> <emphasis>, e que leas o <ulink url="http://svnbook.red-bean.com/">Subversion Book</ulink> e as <ulink url="http://subversion.tigris.org/faq.html">FAQ</ulink>. Podes tamén facer preguntas no IRC en </emphasis> <literal>irc.freenode.net</literal> <emphasis>canal</emphasis>&nbsp;<literal>#svn</literal>.</para> </blockquote> <para>Algúns proxectos ofrecen varios canais, un por subtema. Por exemplo, un canal para problemas de instalación, outro para cuestións sobre o uso, outro para conversas sobre desenvolvemento, etc. (<xref linkend="growth"/><phrase output="printed"> en <xref linkend="comunicacións"/></phrase> trata sobre como subdividir en múltiples canais). Mentres o teu proxecto sexa novo, debería haber un só canal, con todo o mundo charlando nel. Máis tarde, cando o ratio usuario-desenvolvedor crece, a separación de canáis pode volverse necesaria.</para> <para>Como vai saber a xente cales son os canais dispoñibles, e en que canal charlar? E cando falen nun canal, como van saber cales son as regras locais?</para> <para>A resposta está en dicirllo pola vía de establecer o  <firstterm>tema do canal</firstterm>.<footnote><para>Para facelo, usa o comando <literal>/topic</literal>. Todos os comandos no IRC comezan polo carácter "<literal>/</literal>". Bótalle unha ollada a  <ulink url="http://www.irchelp.org/"></ulink> se non estás familiarizado co uso e administración do IRC; en particular, <ulink url="http://www.irchelp.org/irchelp/irctutorial.html"></ulink> é un excelente tutorial.</para></footnote> O tema do canal é unha mensaxe breve que cada usuario ve no momento de entrar no canal. Inclúe instrucións para os novatos e ligazóns a máis información. Por exemplo:</para> <screen>
Estás charlando en #svn

O tema para #svn é o Foro para as cuestións dos usuarios de Subversion, podes visitar tamén
http://subversion.tigris.org/. || As discusións sobre desenvolvemento teñen lugar en
#svn-dev. || Por favor non coles transcricións longas aquí, pola contra usa un sitio como http://pastebin.ca/. || NOVAS: Subversion 1.1.0
foi liberado, máis detalles en ttp://svn110.notlong.com/.
</screen> <para>Xa sei que é pesado, mais infórmalles aos novatos sobre todo o que precisan saber. Di exactamente para que é o canal, facilita o enderezo da páxina do proxecto (para o caso de que alguén se pasee polo canal sen ter visitado antes o sitio web do proxecto), menciona un canal relacionado e dá algúns consellos sobre pegar textos.</para> <sidebar id="sitios-de-pegado"> <title>Sitios de pegado</title> <para>Un canal IRC é un espazo compartido: todo o mundo pode ver o que calquera outro está a escribir. Normalmente isto é bo, xa que permite que a xente se meta nunha conversa cando cre que ten algo co que contribuír, e permite que os observadores aprendan mirando. Mais empeza a ser un problema cando alguén ten unha chea de información que compartir dunha vez, tal como a transcrición dunha sesión de corrección de erros, xa que pegar demasiadas liñas no canal vai entorpecer outras conversas.</para> <para>A solución está en usar un dos sitios <firstterm>pastebin</firstterm> ou <firstterm>pastebot</firstterm>. Cando se precise que alguén aporte uha cantidade grande de datos, non lle pidas que os pegue no chat, senón que vaia (por exemplo) a <ulink url="http://pastebin.ca/"></ulink>, pegue os seus datos no formulario da páxina, e comunique a URL resultante no canal. Calquera poderá visitar a URL e ver os datos. </para> <para> Hai uns cantos sitios gratuítos para pegado de datos na web, demasiados para unha lista entendible, mais estes son alguns dos que eu teño usado: <ulink url="http://www.nomorepasting.com/"></ulink>, <ulink url="http://pastebin.ca/"></ulink>, <ulink url="http://nopaste.php.cd/"></ulink> <ulink url="http://rafb.net/paste/"></ulink> <ulink url="http://sourcepost.sytes.net/"></ulink>, <ulink url="http://extraball.sunsite.dk/notepad.php"></ulink>, e <ulink url="http://www.pastebin.com/"></ulink>.</para> </sidebar>

Bots

Moitos canais IRC orientados a asuntos técnicos inclúen un membro non humano, chamado <firstterm>bot</firstterm>, que é quen de almacenar e devolver información en resposta a certos comandos. Tipicamente, a comunicación co bot faise de xeito exactamente igual que con calquera outro membro do canal, é dicir, os comandos se executan pola vía de "dicirllo" ao bot. Por exemplo:

&lt;kfogel&gt; ayita: learn diff-cmd = http://subversion.tigris.org/faq.html#diff-cmd
&lt;ayita&gt;  Grazas!

Así lle dixo ao bot (que está rexistrado no canal como ayita) que lembre unha certa URL como resposta á consulta "diff.cmd". Agora poderemos dirixirnos a ayita para que informe outro usuario acerca de diff-cmd:

&lt;kfogel&gt; ayita: tell jrandom about diff-cmd
&lt;ayita&gt;  jrandom: http://subversion.tigris.org/faq.html#diff-cmd

O mesmo pode facerse mediante un atallo axeitado:

&lt;kfogel&gt; !a jrandom diff-cmd
&lt;ayita&gt;  jrandom: http://subversion.tigris.org/faq.html#diff-cmd

A configuración exacta do comando e os comportamentos varían dun bot a outro. O exemplo anterior é para <literal>ayita</literal> (<ulink url="http://hix.nu/svn-public/alexis/trunk/"></ulink>do que normalmente hai unha instancia funcionando no canal <literal>#svn</literal> en freenode. Outros bots son Dancer (<ulink url="http://dancer.sourceforge.net/"></ulink>) e Supybot (<ulink url="http://supybot.com/"></ulink>). Non son precisos privilexios especiais para executar un bot. Un bot é un programa cliente; calquera pode pór un en marcha e dirixilo para que escoite un determinado servidor/canal.

Se no teu canal se tende a repetir as mesmas preguntas unha e outra vez, eu recoméndoche implementar un bot. Tan só un número pequeno de usuarios do canal vai adquirir a experiencia necesaria para manipular o bot, mais son os mesmos usuarios que van responder a un número desproporcionadamente grande de cuestións, xa que o bot vailles permitir facelo de xeito moito máis eficiente.

Arquivando o IRC

Aínda que é posible arquivar todo o que ocorre nun canal IRC, non necesariamente se espera que o fagas. As conversacións IRC poden ser nominalmente públicas, mais moita xente pensa que son semiprivadas e informais. Talvez os usuarios non teñan coidado coa gramática, e a miúdo expresen opinións (por exemplo, acerca de outro software ou outros programadores) que non queren que sexan gardadas para sempre nun arquivo en liña.

Por suposto, sempre haberá <emphasis>citas</emphasis> que deberían ser conservadas, e iso está ben. Os máis dos clientes IRC poden rexistrar unha conversación nun ficheiro, ou se iso non é posible, un sempre pode "copiar e pegar" a conversación do IRC a un foro máis permanente (frecuentemente o sistema de xestión de incidencias). Mais tamén o rexistro indiscriminado pode facer que algúns usuarios se sintan incómodos. Se arquivares absolutamente todo, deberías ter a seguridade de que iso está claramente establecido no tema do canal, e que hai unha URL coñecida do arquivo.

RSS Feeds

<firstterm>RSS</firstterm> (Really Simple Syndication) é un mecanismo para distribuír resumos de noticias, moi ricos en metadatos, aos usuarios subscritos, é dicir: á xente que manifestou o seu interese en recibiren eses resumos. Unha fonte RSS determinada é normalmente denominada un <firstterm>feed</firstterm>, e a interface de subscrición é chamada <firstterm>lector de feed</firstterm> ou <firstterm>agregador de feed </firstterm>. <ulink url="http://www.rssbandit.org/">RSS Bandit</ulink> e o epónimo <ulink url="http://www.feedreader.com/">Feedreader</ulink> son dous lectores de RSS de código aberto, por exemplo.

Non hai espazo aquí para facer unha explicación técnica detallada de RSS<footnote><para>podes ver  <ulink url="http://www.xml.com/pub/a/2002/12/18/dive-into-xml.html"></ulink> para maior información.</para></footnote>, mais deberías ter en conta dúas cousas. A primeira é que o software de lectura de feeds é seleccionado polo usuario e vai ser <emphasis>o mesmo</emphasis> para todos os feeds que o subscritor estea a monitorizar&nbsp;&mdash;&nbsp;de feito, este é o maior atractivo de RSS: que o subscritor escolle usar unha interface para todos os feeds, así que cada feed ten que concentrarse exclusivamente en servir os contidos. A segunda é que o RSS é xa ubicuo, tanto que as máis das persoas que están a empregalo nin saben que o usan. Cara á xente en xeral, RSS ten o aspecto dun pequeno botón nunha páxina web, cunha etiqueta que di "Subscríbete a este sitio" ou "Feed de noticias". Ti premes o botón, e de aí en adiante o teu lector de feed (que pode perfectamente ser unha applet embebida na túa páxina web) actualízase automaticamente cada vez que se introduce unha novidade na web de orixe.

Isto quere dicir que o teu proxecto de software de fontes abertas debería probablemente ofrecer un feed RSS (os máis dos sitios de aloxamento preconfigurado xa o ofrecen como opción por defecto&nbsp;&mdash;&nbsp;véxase <xref linkend="aloxamento-preconfigurado"/>&nbsp;&mdash;&nbsp;). Mais ten coidado de non publicares tantas novas ao día que os subscritores non sexan quen de separar o gran da palla. Se hai demasiados eventos de novas, a xente simplemente vai ignorar o feed ou, aínda peor, vaise dar de baixa por desesperación. Idealmente, un proxecto debería ofertar feeds separados: un para os grandes anuncios, outro seguindo (digamos) os eventos do xestor de incidencias, outro para cada lista de correo, etc. Na práctica, isto é difícil de facer en condicións: pode producir confusión de interfaces tanto para os visitantes da web do proxecto como para os administradores. Mais como mínimo, o proxecto debería ofrecer un feed RSS na portada da web para enviar novas sobre os eventos máis relevantes, tales como novas versións ou avisos de seguridade.

Ao César o que é do César <footnote><para>Nota do tradutor: tradución libre do orixinal inglés: "Credit where credit is due"</para></footnote>: esta sección non estaba na primeira edición do libro, mais a entrada <ulink url="http://krow.livejournal.com/564980.html">"Release Criteria, Open Source, Thoughts On..."</ulink> no blog de Brian Aker fíxome decatarme da utilidade dos feed RSS para os proxectos de software de fontes abertas.

Wikis

Unha <firstterm>wiki</firstterm> é un sitio web que permite que cada visitante poida editar e estender os seus contidos; o termo "wiki" (que significa "áxil" ou "super-rápido" en hawaiano) úsase tamén para denominar o software que permite facer esa edición. As wikis foron inventadas en 1995, mais a súa popularidade comezou a aumentar a partir de 2000 ou 2001, acelerada en parte polo éxito da Wikipedia (<ulink url="http://www.wikipedia.org/"></ulink> ou a súa versión en galego: <ulink url="http://gl.wikipedia.org/"></ulink>), unha enciclopedia con contidos libres baseada en wiki. Podes pensar nunha wiki como algo intermedio entre o IRC e as páxinas web: as wikis non se editan en tempo real, de feito que a xente ten tempo de pulir e ponderar as súas contribucións, mais engadirlle contidos é tamén moi doado, implicando menor complexidade que a edición dunha páxina web.

As wikis non son aínda equipamentos estándar para os proxectos de software de fontes abertas, mais probablemente o sexan logo. <footnote><para>Nota do tradutor: de feito, xa no momento de facerse esta tradución (decembro de 2009), practicamente todos os proxectos que se desenvolven de xeito colaborativo contan con cadansúa wiki. Sexa para publicar a documentación e a información de soporte ao usuario, ou como "centro de mando" da totalidade do proxecto</para></footnote>. Como son unha tecnoloxía relativamente nova, e a xente está a experimentar con formas diversas de usalas, vou simplemente aconsellarvos unhas poucas precaucións&mdash;neste punto, é máis doado analizar os usos incorrectos das wikis que os seus éxitos.

Se decidires montar unha wiki, dedica bastante esforzo a conseguir unha organización clara da páxina e unha distribución visual agradable, para que os visitantes (p.e.: editores potenciais) saiban de xeito instintivo como encaixar as súas contribucións. Igualmente importante, publica as instrucións na propia wiki, así a xente terá un sitio ao que acudiren en busca de axuda. Con demasiada frecuencia, os administradores de wikis caen vítimas da fantasía de que, xa que hordas de visitantes van engadir á wiki contidos de alta calidade, a suma de todas as contribucións individuais vai ser en consecuencia de alta calidade. Non é así como traballan os sitios web. Cada páxina individual ou parágrafo pode ser bo se se considera isoladamente, mais pode non selo se está integrado nun conxunto confuso ou desorganizado. Moi frecuentemente, as wikis sofren de:

<emphasis role="bold">Ausencia de principios de navegación.</emphasis> Un sitio web ben organizado fai que os visitantes sintan que saben onde están en cada momento. Por exemplo, se as páxinas están ben deseñadas, a xente vai saber intuitivamente a diferenza entre unha rexión de "táboa de contidos" e unha rexión de "contidos". Os contribuidores a unha wiki van respectar esa diferenza, mais só se a diferenza está claramente establecida desde o principio.

<emphasis role="bold">Duplicación da información.</emphasis> As wikis acaban frecuentemente con varias páxinas dicindo cousas similares, dado que os contribuidores individuais non van ser conscientes da duplicación. Isto pode ser consecuencia en parte da ausencia de principios de navegación comentados antes, debido a que a xente pode non atopar os contidos duplicados se non están onde esperan que estean.

<emphasis role="bold">Audiencia obxectivo mal definida.</emphasis> Ata un certo punto, este problema é inevitable cando hai tantos autores diferentes, mais pode ser minimizado se previamente se escriben unha serie de consellos e guías acerca de como crear novos contidos. Editar unha chea de novos contidos a modo de exemplo ao principio tamén axuda, de xeito que os estándares fiquen xa afirmados.

A solución máis común a todos estes problemas é a mesma: fixar estándares editoriais, e demostralos non só publicándoos, se non publicando páxinas que os poñan en práctica. En xeral, as wikis van amplificar calquera erro nos seus materiais orixinais, xa que os colaboradores tenden a imitar os padróns que teñen á vista. Non poñas en marcha a wiki e fiques esperando a que todo axuste axeitadamente. Deberás tamén alimentala con materiais escritos, para que a xente teña un modelo que seguir.

O exemplo máis brillante dunha wiki ben administrada é a Wikipedia, aínda que isto pode ser así en parte porque os seus contidos (entradas dunha enciclopedia) encaixan de forma natural co formato wiki. Mais se examinares atentamente a Wikipedia, verás que os seus administradores deseñaron unha <emphasis>moi</emphasis> ben pensada infraestrutura para a cooperación. Hai unha boa cantidade de documentación sobre como escribir novas entradas, como manter un axeitado punto de vista, que clase de edicións facer, que edicións evitar, un procedemento para a resolución de disputas a respecto de edicións controvertidas (a base de varios pasos, incluíndo eventualmente a arbitraxe), etc. Tamén teñen controis de autoría, de xeito que se unha páxina é obxecto de repetidas edicións inapropiadas, poden bloqueala ata que o problema se resolve. En outras verbas, os seus autores non se limitaron a pór unha serie de moldes nunha web e esperar o mellor. Wikipedia funciona porque os seus fundadores pensaron coidadosamente acerca de como conseguir que milleiros de estranos axustasen os seus escritos a unha visión común. Aínda que ti seguramente non vas precisar un nivel preciso de preparación para montar a wiki dun proxecto de software de fontes abertas, paga a pena emular o seu espírito.

Para máis información acerca das wikis, podes consultar <ulink url="http://en.wikipedia.org/wiki/Wiki"></ulink>. Tamén a primeira wiki está viva e goza de boa saúde, e contén unha chea de discusións acerca de como administrar wikis: podes ver <ulink url="http://www.c2.com/cgi/wiki?WelcomeVisitors"></ulink>, <ulink url="http://www.c2.com/cgi/wiki?WhyWikiWorks"></ulink>, e <ulink url="http://www.c2.com/cgi/wiki?WhyWikiWorksNot"></ulink> para analizares varios puntos de vista sobre o tema.

Páxina web

Non hai moito que dicir acerca da posta en marcha da web dun proxecto desde un punto de vista técnico: montar un sitio web e escribir páxinas son tarefas realmente simples, e as máis das cousas importantes que se poden dicir acerca do seu deseño e distribución de contidos foron xa comentadas no capítulo anterior. A principal función do sitio web é a de presentar unha clara e amena visión xeral do proxecto, e enmarcar as restantes ferramentas (o sistema de control de versións, o xestor de incidencias, etc.) Se non es experto na construción de webs, xeralmente non che vai ser difícil atopares alguén que si o é e que estea desexando axudar na materia. Porén, para aforrar tempo e esforzos, a xente xeralmente prefire facer uso de webs pre-enlatadas.

Aloxamento preenlatado

Usar un sitio preconfigurado ou preenlatado ten moitas vantaxes. A primeira é a capacidade do servidor e o largo de banda: os seus servidores son caixas enormes conectadas a cabos moi grosos. Por moito éxito que teña o teu proxecto, nunca vas esgotar o espazo en disco ou colapsar a conexión de rede. A segunda vantaxe é a simplicidade. Xa che van dar escollidos un xestor de incidencias, un sistema de control de versións, un xestor de listas de correo, un arquivo, e calquera outra utilidade que poidas precisar para controlar o teu proxecto. As ferramentas estarán xa configuradas, e serán eles quen se ocupen de facer as copias de seguridade de todos os datos almacenados nas ferramentas. Terás poucas decisións que tomar. Todo o que terás que facer e preencher un formulario, premer un botón, e terás de súpeto un sitio web para o teu proxecto.

Estes son beneficios significativos dabondo. A desvantaxe, claro, é que ti vas ter que aceptar <emphasis>as súas</emphasis> eleccións e configuracións, aínda que algo diferente puidese ser mellor para o teu proxecto. Xeralmente os sitios preenlatados poden ser axustados dentro dun certo número de parámetros, mais nunca chegarás a ter o control refinado que atinxirías se instalases e configurases por ti mesmo o sitio e tiveses acceso administrativo completo ao servidor.

Un exemplo perfecto do que digo é o manexo de ficheiros xerados. Algunhas páxinas web do proxecto poden ser ficheiros xerados&mdash;por exemplo, hai sistemas para manter os datos das FAQ nun formato mestre doado de editar, desde o que se poden xerar HTML, PDF, e outros formatos de presentación. Como se explica en <xref linkend="versionea-todo"/><phrase output="printed"> neste mesmo capítulo</phrase>, non deberías pretender versionar os formatos xerados, só o ficheiro mestre. Mais cando o teu sitio web está aloxado no servidor dun terceiro, pode que sexa imposible dispor dun hook personalizado para xerar a versión HTML da FAQ cada vez que se modifique o ficheiro mestre. A única solución será versionar tamén os formatos xerados, para que se poidan publicar no sitio web.

Pode tamén haber consecuencias máis importantes. Talvez non teñas tanto control sobre a presentación como che gustaría. Algúns dos sitios preenlatados permitiranche personalizar as páxinas web, mais o deseño por defecto da web vaise facer presente en variadas e molestas formas. Por exemplo, algúns dos proxectos hospedados en SourceForge teñen as súas páxinas completamente personalizadas, mais aínda dirixen os desenvolvedores á súa "páxina en SourceForge" para información adicional. A páxina en SourceForge é o que sería a páxina do proxecto se non tivese un sitio web propio. Ten ligazóns ao xestor de incidencias, ao repositorio do CVS, descargas, etc. Por desgraza, unha páxina de SourceForge contén tamén unha certa cantidade de ruído estrano. A parte superior é unha banda publicitaria, e frecuentemente unha imaxe animada. No lado esquerdo contén unha banda de ligazóns de escasa relevancia para quen está interesado no proxecto. O lado dereito contén frecuentemente máis publicidade. Tan só o centro de páxina está dedicado a materiais realmente específicos do proxecto, e mesmo neste caso están dispostos dun xeito confuso que frecuentemente fai que o visitante non saiba onde premer a continuación

Detrás de cada aspecto individual do deseño de SourceForge, hai sen dúbida unha boa razón&mdash;boa desde o punto de vista de SourceForge, tal como a publicidade. Mais desde o punto de vista dun proxecto individual, o resultado pode ser unha web máis que afastada do ideal. Non estou a botar pedras contra SourceForge; problemas similares ocorren cos máis dos servizos de hospedaxe enlatada. A cousa é que hai un compromiso. Ficas liberado das cargas técnicas derivadas da xestión do sitio do proxecto, mais polo prezo de teres que aceptar a maneira en que outros decidan como xestionalo.

Soamente ti podes decidir se os sitios enlatados son a mellor solución para o teu proxecto. Se elixires un sitio enlatado, deixa aberta a posibilidade de migrar aos teus propios servidores máis tarde, empregando un nome de dominio personalizado para a URL do proxecto. Podes reenviar a URL ao sitio enlatado, ou crear unha páxina de inicio completamente persoal na URL pública e mandar os usuarios ao sitio enlatado para faceren uso das funcionalidades sofisticadas. Tan só asegúrate de arranxares as cousas de xeito que se posteriormente decides empregar unha solución de aloxamento distinta, o enderezo do proxecto non teña que ser modificado.

Escollendo un sitio enlatado

O sitio enlatado máis grande e mellor coñecido é <ulink url="http://www.sourceforge.net/">SourceForge</ulink>. Outros dous sitios que fornecen servizos iguais ou similares son <ulink url="http://savannah.gnu.org/">savannah.gnu.org</ulink> e <ulink url="http://www.berlios.de/">BerliOS.de</ulink><footnote><para>Nota do tradutor: en Galiza, o sitio máis coñecido é a <ulink url="https://forxa.mancomun.org/">Forxa de Mancomún</ulink></para></footnote>. Algunhas organizacións, tales como a <ulink url="http://www.apache.org/">Apache Software Foundation</ulink> e <ulink url="http://www.tigris.org/">Tigris.org</ulink><footnote><para>Aviso: eu son empregado de <ulink url="http://www.collab.net/">CollabNet</ulink>, que patrocina a Tigris.org, e emprego Tigris regularmente.</para></footnote>, fornecen aloxamento gratis a proxectos de código aberto que encaixan coas súas misións e coa súa comunidade de proxectos existentes.

Haggen So fixo unha avaliación de varios sitios de aloxamento de proxectos como parte do seu traballo de investigación para a súa tese de doutoramento, <citetitle>Construction of an Evaluation Model for Free/Open Source Project Hosting (FOSPHost) sites</citetitle>. Os resultados están publicados en <ulink url="http://www.ibiblio.org/fosphost/"></ulink>, onde podes ver especialmente a tabela excelente comparativa en <ulink url="http://www.ibiblio.org/fosphost/exhost.htm"></ulink>.

Anonimato e participación

Un problema que non se dá só nos sitios enlatados, mais que se ten atopado especialmente neles, é o abuso da funcionalidade de login (rexistro de entrada). En sí mesma é considerablemente simple: o sitio permite que cada visitante se cadastre cun nome de usuario e unha seña. Desde ese momento, mantén un perfil do usuario, e os administradores do proxecto poden asignarlle certos permisos, por exemplo o dereito a achegar mudanzas ao repositorio.

Isto pode ser extremadamente útil e, de feito, é unha das vantaxes principais do aloxamento enlatado. O problema é que ás veces o rexistro de usuario acaba sendo necesario para tarefas que deberían ser permitidas a visitantes non rexistrados, especialmente a capacidade de rexistrar asuntos no xestor de incidencias, e de poder facer comentarios sobre asuntos abertos. Requirindo un nome de usuario rexistrado para tales accións, o proxecto eleva o limiar para o que debería poder facerse de xeito áxil e doado. Por suposto, é interesante poder contactar con quen ten introducido asuntos no xestor de incidencias, mais tendo un campo onde introducir o enderezo de correo-e (se o usuario o desexa) chega dabondo. Se un novo usuario localiza unha incidencia e quere reportala, sentirase molestado por ter que preencher un formulario de creación dunha conta antes de poder rexistrar o asunto no xestor de incidencias. Talvez simplemente renuncie a rexistrar a incidencia.

As vantaxes da xestión de usuarios xeralmente ultrapasan as desvantaxes. Mais se podes escoller que accións poden levarse a cabo de xeito anónimo, asegúrate de que non só están permitidas para visitantes non rexistrados<emphasis>todas</emphasis> as accións de só lectura, senón que tamén o están algunhas de entrada de datos, especialmente no xestor de incidencias e, se a tiveres, nas páxinas wiki.